import os
import subprocess
import sys
import importlib.util
import shutil

setup_content_protected_module = f"""
from setuptools import setup, find_packages

setup(
    name='memilio-stubs',
    version='0.1',
    packages=['memilio-stubs'],
    package_data={{
        'memilio-stubs': ['simulation/*.pyi'],
    }},
)
"""

# Define if the generated stubs of mypy should be configured
# For testing can set this to False
flag_configure_generated_stubs = True

if __name__ == "__main__":

    python_interpreter = sys.executable

    # Check for needed packages. If it fails either pacakge is not installed or the wrong python interpreter is detected.
    # For the latter try setting python_interpreter with full path
    if importlib.util.find_spec('mypy') is None:
        print('pybind11_stubgen is not installed')
        exit()
    if importlib.util.find_spec('memilio.simulation') is None:
        print('memilio.simulation is not installed')
        exit()

    file_path = os.path.dirname(os.path.abspath(__file__))
    package_dir = os.path.abspath(os.path.join(
        file_path, "../../memilio-simulation-stubs"))

    # delete stubs if they already exist
    try:
        shutil.rmtree(os.path.join(package_dir, "memilio-stubs"))
    except:
        pass

    # create folders, if they do not exist
    try:
        os.makedirs(package_dir)
    except:
        pass

    # memilio-stubs/simulation module needs same structure as memilio/simulation
    # test --include-docstrings, --doc-dir PATH for better docs
    subprocess.check_call(
        ['stubgen', '--include-docstrings', '-o', package_dir, '-p', 'memilio.simulation'])

    # TODO: several error in the stubs (output of running mypy on codebase with stubs generated by mypy, need to set flag_configure_generated_stubs=False)
    #   - fix numpy.float64[m, 1] to numpy.float64[M, Literal(1)] with M = typing.TypeVar("M", bound=int) at top of file
    #   - or numpy.ndarray[numpy.float64[m, 1]] to numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]
    #   - also numpy.ndarray[numpy.float64[m, n], flags.f_contiguous] needs to get n defined
    #   - change following error:
    #   def __eq__(self, other: object) -> bool:
    #       if not isinstance(other, Index_SimulationDay):
    #           return NotImplemented
    #       return <logic to compare two Index_SimulationDay instances>
    #
    if flag_configure_generated_stubs:
        list_protected_module_file_paths = []

        stub_files_path = os.path.join(package_dir, "memilio/simulation")
        protected_module_file_path = os.path.join(
            stub_files_path, "_simulation.pyi")
        with open(protected_module_file_path, encoding='utf-8') as file:
            content_protected_module = file.read()

        # # Replace the old namespace with the new one
        content_protected_module = content_protected_module.replace(
            "simulation._simulation", "simulation")

        module_file_path = os.path.join(stub_files_path, "__init__.pyi")
        with open(module_file_path, encoding='utf-8') as file:
            content_module = file.read()

        content_module = content_module.replace(
            "from memilio.simulation._simulation import *" + os.linesep, "")

        import_submodules_string = [
            "from memilio.simulation import (",
            "    abm as abm,",
            "    osir as osir,",
            "    oseir as oseir,",
            "    osecir as osecir,",
            "    osecirvvs as osecirvvs,",
            ")"]
        import_submodules_string = (os.linesep).join(import_submodules_string)

        content_protected_module = import_submodules_string + os.linesep + \
            content_protected_module + os.linesep + content_module

        # Write the modified content_protected_module back to the file
        with open(module_file_path, 'w', encoding='utf-8') as file:
            file.write(content_protected_module)

        # remove the protected module file
        os.remove(protected_module_file_path)

        # get all model modules from memilio.simulation
        # if package structure changes this needs to be adjusted
        models = [f.rstrip(".py") for f in os.listdir(os.path.join(
            file_path, "../memilio/simulation")) if f.endswith(".py")]
        models.remove("__init__")

        for model in models:
            protected_module_file_path = os.path.join(
                stub_files_path, "_simulation_" + model + ".pyi")
            with open(protected_module_file_path, encoding='utf-8') as file:
                content_protected_module = file.read()

            # # Replace the old namespace with the new one
            content_protected_module = content_protected_module.replace(
                "_simulation_" + model, model)
            content_protected_module = content_protected_module.replace(
                "simulation._simulation", "simulation")

            module_file_path = os.path.join(stub_files_path, model + ".pyi")
            with open(module_file_path, encoding='utf-8') as file:
                content_module = file.read()

            content_module = content_module.replace(
                "from memilio.simulation._simulation_" + model + " import *" + os.linesep, "")

            content_protected_module = content_protected_module + os.linesep + content_module

            # Write the modified content_protected_module back to the file
            with open(module_file_path, 'w', encoding='utf-8') as file:
                file.write(content_protected_module)

            # remove the protected module file
            os.remove(protected_module_file_path)

    # rename directory memilio to memilio-stubs
    shutil.move(os.path.join(package_dir, "memilio"),
                os.path.join(package_dir, "memilio-stubs"))

    # create setup.py and install package
    with open(os.path.join(package_dir, "setup.py"), "w") as setup_file:
        setup_file.write(setup_content_protected_module)
    subprocess.check_call(
        [python_interpreter, '-m', 'pip', 'install', package_dir])
