<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HPC against Corona: epi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HPC against Corona
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">epi Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file describes the framework for IO.  
<a href="namespaceepi.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceepi_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceepi_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi_1_1details.html">details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceepi_1_1regions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi_1_1regions.html">regions</a></td></tr>
<tr class="memdesc:namespaceepi_1_1regions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utilities that depend on geographical regions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1AbmSimulation.html">AbmSimulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">run the simulation in discrete steps, evolve the world and report results.  <a href="classepi_1_1AbmSimulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1AgeGroup.html">AgeGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structepi_1_1AgeGroup.html" title="The AgeGroup struct is used as a dynamically sized tag for all age dependent categories.">AgeGroup</a> struct is used as a dynamically sized tag for all age dependent categories.  <a href="structepi_1_1AgeGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1AsymptoticCasesPerInfectious.html">AsymptoticCasesPerInfectious</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the percentage of asymptomatic cases in the SECIR model  <a href="structepi_1_1AsymptoticCasesPerInfectious.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1BasicShoppingRate.html">BasicShoppingRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1CarrierToInfected.html">CarrierToInfected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1CarrierToRecovered.html">CarrierToRecovered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ColumnVectorShape.html">ColumnVectorShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape of a column vector.  <a href="classepi_1_1ColumnVectorShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1CompartmentalModel.html">CompartmentalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ComppartmentalModel is a template for a compartmental model for an array of initial populations and a parameter set.  <a href="structepi_1_1CompartmentalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">conjunction (logical and) of zero or more type traits with bool values.  <a href="structepi_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1conjunction_3_01B1_01_4.html">conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1conjunction_3_01B1_00_01Bn_8_8_8_01_4.html">conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ConstVisitor.html">ConstVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ConstVisitor_3_01T_01_4.html">ConstVisitor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ConstVisitor_3_01T_00_01Types_8_8_8_01_4.html">ConstVisitor&lt; T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ContactFrequency.html">ContactFrequency</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ContactMatrix.html">ContactMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents time dependent contact frequencies between groups.  <a href="classepi_1_1ContactMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ContactMatrixGroup.html">ContactMatrixGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a collection of contact frequency matrices that whose sum is the total number of contacts.  <a href="classepi_1_1ContactMatrixGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ContactPatterns.html">ContactPatterns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the contact patterns within the society are modelled using an <a class="el" href="classepi_1_1UncertainContactMatrix.html" title="The UncertainContactMatrix class consists of a ContactMatrix with fixed baseline and uncertain Dampin...">UncertainContactMatrix</a>  <a href="structepi_1_1ContactPatterns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1CriticalToDead.html">CriticalToDead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1CriticalToRecovered.html">CriticalToRecovered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1CustomIndexArray.html">CustomIndexArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template for an array with custom indices.  <a href="classepi_1_1CustomIndexArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1CVPlainMatrix.html">CVPlainMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to get the matrix type from an eigen expression with correct const volatile qualitfications.  <a href="structepi_1_1CVPlainMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1CVPlainMatrix_3_01Eigen_1_1Ref_3_01const_01M_01_4_01_4.html">CVPlainMatrix&lt; Eigen::Ref&lt; const M &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Damping.html">Damping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represent interventions or effects that affect contact frequencies between multiple groups.  <a href="classepi_1_1Damping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1DampingMatrixExpression.html">DampingMatrixExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the coefficient wise matrix (or vector) expression B - D * M where B is a baseline, M is a minimum and D is some time dependent complex damping factor.  <a href="classepi_1_1DampingMatrixExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1DampingMatrixExpressionGroup.html">DampingMatrixExpressionGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a collection of DampingMatrixExpressions that are summed up.  <a href="classepi_1_1DampingMatrixExpressionGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Dampings.html">Dampings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">collection of dampings at different time points.  <a href="classepi_1_1Dampings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1DampingSampling.html">DampingSampling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">randomly sample dampings for e.g.  <a href="classepi_1_1DampingSampling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Date.html">Date</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple date representation as year, month, and day.  <a href="structepi_1_1Date.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1DeathsPerHospitalized.html">DeathsPerHospitalized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the percentage of dead patients per ICU patients in the SECIR model  <a href="structepi_1_1DeathsPerHospitalized.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1DetectInfection.html">DetectInfection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1DiscreteDistributionInPlace.html">DiscreteDistributionInPlace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">select a random integer in [0, n) with weights [w_0, ..., w_(n-1)] the probability to pick i is w_i/S where S is the sum of all weights.  <a href="classepi_1_1DiscreteDistributionInPlace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapter for a random number distribution.  <a href="classepi_1_1DistributionAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1DynamicNPIs.html">DynamicNPIs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents non-pharmaceutical interventions (NPI) that are activated during the simulation if some value (e.g.  <a href="classepi_1_1DynamicNPIs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1DynamicNPIsInfected.html">DynamicNPIsInfected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the NPIs that are enacted if certain infection thresholds are exceeded.  <a href="structepi_1_1DynamicNPIsInfected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents an edge of the graph  <a href="structepi_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1EdgeBase.html">EdgeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1EffectiveContacts.html">EffectiveContacts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1EulerIntegratorCore.html">EulerIntegratorCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple explicit euler integration y(t+1) = y(t) + h*f(t,y) for ODE y'(t) = f(t,y)  <a href="classepi_1_1EulerIntegratorCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic graph structure  <a href="classepi_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1GraphSimulation.html">GraphSimulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract simulation on a graph with alternating node and edge actions  <a href="classepi_1_1GraphSimulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1H5DataSet.html">H5DataSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII for HDF5 data set handles.  <a href="structepi_1_1H5DataSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1H5DataSpace.html">H5DataSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII for HDF5 data space handles.  <a href="structepi_1_1H5DataSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1H5File.html">H5File</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII for HDF5 file handles.  <a href="structepi_1_1H5File.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1H5Group.html">H5Group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII for HDF5 group handles.  <a href="structepi_1_1H5Group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1HomeToHospitalizedTime.html">HomeToHospitalizedTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the time people are infectious at home before 'simply' hospitalized in the SECIR model in day unit  <a href="structepi_1_1HomeToHospitalizedTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1HospitalizedCasesPerInfectious.html">HospitalizedCasesPerInfectious</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the percentage of hospitalized patients per infected patients in the SECIR model  <a href="structepi_1_1HospitalizedCasesPerInfectious.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1HospitalizedToHomeTime.html">HospitalizedToHomeTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the time people are 'simply' hospitalized before returning home in the SECIR model in day unit  <a href="structepi_1_1HospitalizedToHomeTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1HospitalizedToICUTime.html">HospitalizedToICUTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the time people are 'simply' hospitalized before being treated by ICU in the SECIR model in day unit  <a href="structepi_1_1HospitalizedToICUTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ICUCapacity.html">ICUCapacity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the icu capacity in the SECIR model  <a href="structepi_1_1ICUCapacity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ICUCasesPerHospitalized.html">ICUCasesPerHospitalized</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the percentage of ICU patients per hospitalized patients in the SECIR model  <a href="structepi_1_1ICUCasesPerHospitalized.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ICUToDeathTime.html">ICUToDeathTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the time people are treated by ICU before dying in the SECIR model in day unit  <a href="structepi_1_1ICUToDeathTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ICUToHomeTime.html">ICUToHomeTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the time people are treated by ICU before returning home in the SECIR model in day unit  <a href="structepi_1_1ICUToHomeTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ImplicitEulerIntegratorCore.html">ImplicitEulerIntegratorCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit Euler integration (not generalized, adapted to SECIHURD-model)  <a href="classepi_1_1ImplicitEulerIntegratorCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1IncubationPeriod.html">IncubationPeriod</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1IncubationTime.html">IncubationTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the incubation time in the SECIR model  <a href="structepi_1_1IncubationTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Index.html">Index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classepi_1_1Index.html" title="An Index with more than one template parameter combines several Index objects.">Index</a> with more than one template parameter combines several <a class="el" href="classepi_1_1Index.html" title="An Index with more than one template parameter combines several Index objects.">Index</a> objects.  <a href="classepi_1_1Index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Index_3_01CategoryTag_01_4.html">Index&lt; CategoryTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classepi_1_1Index.html" title="An Index with more than one template parameter combines several Index objects.">Index</a> with a single template parameter is a typesafe wrapper for size_t that is associated with a Tag.  <a href="classepi_1_1Index_3_01CategoryTag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1InEdgeBase.html">InEdgeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1InfectedToRecovered.html">InfectedToRecovered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1InfectedToSevere.html">InfectedToSevere</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1InfectionProbabilityFromContact.html">InfectionProbabilityFromContact</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">probability of getting infected from a contact  <a href="structepi_1_1InfectionProbabilityFromContact.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1InfectiousTimeAsymptomatic.html">InfectiousTimeAsymptomatic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the infectious time for asymptomatic cases in the SECIR model in day unit  <a href="structepi_1_1InfectiousTimeAsymptomatic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1InfectiousTimeMild.html">InfectiousTimeMild</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the infectious time for symptomatic cases that are infected but who do not need to be hsopitalized in the SECIR model in day unit  <a href="structepi_1_1InfectiousTimeMild.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1IntegratorCore.html">IntegratorCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1IOStatus.html">IOStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> represents the result of an operation.  <a href="classepi_1_1IOStatus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1is__dynamic__matrix.html">is_dynamic_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Eigen::Matrix type M is a dynamic matrix type.  <a href="structepi_1_1is__dynamic__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1is__dynamic__vector.html">is_dynamic_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Eigen::Matrix type M is a dynamic vector type.  <a href="structepi_1_1is__dynamic__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines static constant value = true if Expr&lt;T...&gt; produces a valid type.  <a href="structepi_1_1is__expression__valid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1JsonBase.html">JsonBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementations of serialization framework concepts.  <a href="classepi_1_1JsonBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1JsonContext.html">JsonContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implemenetation of IOContext concept for JSON format.  <a href="classepi_1_1JsonContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1JsonObject.html">JsonObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the IOObject concept for JSON format.  <a href="classepi_1_1JsonObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1JsonSerializer.html">JsonSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main class for (de-)serialization from/into json.  <a href="classepi_1_1JsonSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType.html">JsonType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structepi_1_1JsonType.html" title="JsonType allows the conversion of basic types for serialization.">JsonType</a> allows the conversion of basic types for serialization.  <a href="structepi_1_1JsonType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01bool_01_4.html">JsonType&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01const_01char_01_5_01_4.html">JsonType&lt; const char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01double_01_4.html">JsonType&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01float_01_4.html">JsonType&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01int64__t_01_4.html">JsonType&lt; int64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01std_1_1string_01_4.html">JsonType&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01T_00_01std_1_1enable__if__t_3_01conjunction__v_3_01is__small__integralc4a7e315d5a71f8971c06050e6f5cbf4.html">JsonType&lt; T, std::enable_if_t&lt; conjunction_v&lt; is_small_integral&lt; T &gt;, std::is_signed&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01T_00_01std_1_1enable__if__t_3_01conjunction__v_3_01is__small__integral8ac92558b8b5c0b7f1eaad5849ac7300.html">JsonType&lt; T, std::enable_if_t&lt; conjunction_v&lt; is_small_integral&lt; T &gt;, std::is_unsigned&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1JsonType_3_01uint64__t_01_4.html">JsonType&lt; uint64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Location.html">Location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">all locations in the simulated world where persons gather.  <a href="classepi_1_1Location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1LocationId.html">LocationId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structepi_1_1LocationId.html" title="LocationId identifies a Location uniquely.">LocationId</a> identifies a <a class="el" href="classepi_1_1Location.html" title="all locations in the simulated world where persons gather.">Location</a> uniquely.  <a href="structepi_1_1LocationId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1LockdownDate.html">LockdownDate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters that govern the migration between locations  <a href="structepi_1_1LockdownDate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1MaxRiskOfInfectionFromSympomatic.html">MaxRiskOfInfectionFromSympomatic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">risk of infection from symptomatic cases increases as test and trace capacity is exceeded.  <a href="structepi_1_1MaxRiskOfInfectionFromSympomatic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the migration between two nodes.  <a href="classepi_1_1MigrationEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1MigrationParameters.html">MigrationParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters that influence migration.  <a href="classepi_1_1MigrationParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a node of the graph  <a href="structepi_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1NoDefaultInit.html">NoDefaultInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag used for tag-dispatching the Constructor of <a class="el" href="classepi_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a>, triggering default initialization of all parameters using the get_default member function.  <a href="structepi_1_1NoDefaultInit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1observer__ptr.html">observer_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning pointer.  <a href="classepi_1_1observer__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1OdeIntegrator.html">OdeIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate initial value problems (IVP) of ordinary differential equations (ODE) of the form y' = f(y, t), y(t0) = y0.  <a href="classepi_1_1OdeIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1OperatorAdditionSubtraction.html">OperatorAdditionSubtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class to add default operator +, +=, -, -= to a class derived from <a class="el" href="classepi_1_1TypeSafe.html" title="typesafe wrapper around any type to make function arguments, tuple elements, etc.">TypeSafe</a>.  <a href="classepi_1_1OperatorAdditionSubtraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1OperatorComparison.html">OperatorComparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class to add operator &lt;, &lt;=, &gt;, &gt;= to a class derived from <a class="el" href="classepi_1_1TypeSafe.html" title="typesafe wrapper around any type to make function arguments, tuple elements, etc.">TypeSafe</a>.  <a href="classepi_1_1OperatorComparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1OperatorIncrementDecrement.html">OperatorIncrementDecrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class to add operator ++, &ndash; (pre- and post-) to a class derived from <a class="el" href="classepi_1_1TypeSafe.html" title="typesafe wrapper around any type to make function arguments, tuple elements, etc.">TypeSafe</a>.  <a href="classepi_1_1OperatorIncrementDecrement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1OperatorScalarMultiplicationDivision.html">OperatorScalarMultiplicationDivision</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class to add operator *, *=, /, /= with a scalar to a class derived from <a class="el" href="classepi_1_1TypeSafe.html" title="typesafe wrapper around any type to make function arguments, tuple elements, etc.">TypeSafe</a>.  <a href="classepi_1_1OperatorScalarMultiplicationDivision.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1OutEdgeBase.html">OutEdgeBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ParameterDistribution.html">ParameterDistribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a set of parameters defined at compile time  <a href="classepi_1_1ParameterSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1ParameterStudy.html">ParameterStudy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that performs multiple simulation runs with randomly sampled parameters.  <a href="classepi_1_1ParameterStudy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1ParameterTagTraits.html">ParameterTagTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the properties of a parameter  <a href="structepi_1_1ParameterTagTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Person.html">Person</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agents in the simulated world that can carry and spread the infection.  <a href="classepi_1_1Person.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1PointerDereferencingIterator.html">PointerDereferencingIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator adaptor that makes a range of T* look like a range of T e.g.  <a href="classepi_1_1PointerDereferencingIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Populations.html">Populations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class template for compartment populations.  <a href="classepi_1_1Populations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1RandomNumberGenerator.html">RandomNumberGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">models a uniform_random_bit_generator.  <a href="classepi_1_1RandomNumberGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">immutable random access range, e.g.  <a href="classepi_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1RecoveredToSusceptible.html">RecoveredToSusceptible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1RectMatrixShape.html">RectMatrixShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape of a rectangular matrix.  <a href="classepi_1_1RectMatrixShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1RelativeCarrierInfectability.html">RelativeCarrierInfectability</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the relative carrier infectability  <a href="structepi_1_1RelativeCarrierInfectability.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1RiskOfInfectionFromSympomatic.html">RiskOfInfectionFromSympomatic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the risk of infection from symptomatic cases in the SECIR model  <a href="structepi_1_1RiskOfInfectionFromSympomatic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1RKIntegratorCore.html">RKIntegratorCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two scheme Runge-Kutta numerical integrator with adaptive step width.  <a href="classepi_1_1RKIntegratorCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterate over elements of eigen matrix expressions in row major order.  <a href="classepi_1_1RowMajorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1SchoolRatio.html">SchoolRatio</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Seasonality.html">Seasonality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the seasonality in the SECIR model the seasonality is given as (1+k*sin()) where the sine curve is below one in summer and above one in winter  <a href="structepi_1_1Seasonality.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1SecirModel.html">SecirModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1SecirParams.html">SecirParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of an age-resolved SECIR/SECIHURD model.  <a href="classepi_1_1SecirParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1SecirSimulation.html">SecirSimulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of compartment model simulation for secir models.  <a href="classepi_1_1SecirSimulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1SecirSimulationResult.html">SecirSimulationResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1SeirModel.html">SeirModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Seq.html">Seq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sequence of indices  <a href="structepi_1_1Seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1SerialInterval.html">SerialInterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the serial interval in the SECIR model in day unit  <a href="structepi_1_1SerialInterval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1SevereToCritical.html">SevereToCritical</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1SevereToRecovered.html">SevereToRecovered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Simulation.html">Simulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the simulation of a compartment model.  <a href="classepi_1_1Simulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the simulation in one node of the graph.  <a href="classepi_1_1SimulationNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">double simulation time.  <a href="classepi_1_1SimulationTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1SocialEventRate.html">SocialEventRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Span.html">Span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reference to any contigiuous array of objects.  <a href="classepi_1_1Span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1SquareMatrixShape.html">SquareMatrixShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape of a square matrix.  <a href="classepi_1_1SquareMatrixShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1StageTimeIncubationInv.html">StageTimeIncubationInv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1StageTimeInfectiousInv.html">StageTimeInfectiousInv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1StartDay.html">StartDay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the start day in the SECIR model The start day defines in which season the simulation can be started If the start day is 180 and simulation takes place from t0=0 to tmax=100 the days 180 to 280 of the year are simulated  <a href="structepi_1_1StartDay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1SusceptibleToExposedByCarrier.html">SusceptibleToExposedByCarrier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1SusceptibleToExposedByInfected.html">SusceptibleToExposedByInfected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1Tableau.html">Tableau</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two scheme Runge-Kutta numerical integrator with adaptive step width for ODE y'(t) = f(t,y) which is given by y_{n+1} = y_n + h*\sum_{i=1}^lb_ik_{ni} with k_{ni} = f(t_n + c_i*h, y_n + h*\sum_{j=1}^{i-1}a_{ij}k_{nj}) where the general Butcher tableau is 0 | c_2 | a_{21} c_3 | a_{31} a_{32} ...  <a href="classepi_1_1Tableau.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1TableauFinal.html">TableauFinal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1TestAndTraceCapacity.html">TestAndTraceCapacity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">capacity to test and trace contacts of infected for quarantine per day.  <a href="structepi_1_1TestAndTraceCapacity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a point in time.  <a href="classepi_1_1TimePoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores vectors of values at time points (or some other abstract variable) the value at each time point is a vector.  <a href="classepi_1_1TimeSeries.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1TimeSeriesTimeIterator.html">TimeSeriesTimeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over vector values of a time series by time point.  <a href="classepi_1_1TimeSeriesTimeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1TimeSeriesValueIterator.html">TimeSeriesValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over vector values of a time series by time point.  <a href="classepi_1_1TimeSeriesValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a duration of time.  <a href="classepi_1_1TimeSpan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1TransmissionRisk.html">TransmissionRisk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1TypeSafe.html">TypeSafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">typesafe wrapper around any type to make function arguments, tuple elements, etc.  <a href="classepi_1_1TypeSafe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1UncertainContactMatrix.html">UncertainContactMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classepi_1_1UncertainContactMatrix.html" title="The UncertainContactMatrix class consists of a ContactMatrix with fixed baseline and uncertain Dampin...">UncertainContactMatrix</a> class consists of a <a class="el" href="classepi_1_1ContactMatrix.html" title="represents time dependent contact frequencies between groups.">ContactMatrix</a> with fixed baseline and uncertain <a class="el" href="classepi_1_1Dampings.html" title="collection of dampings at different time points.">Dampings</a>.  <a href="classepi_1_1UncertainContactMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1UncertainValue.html">UncertainValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classepi_1_1UncertainValue.html" title="The UncertainValue class consists of a scalar value and a Distribution object.">UncertainValue</a> class consists of a scalar value and a Distribution object.  <a href="classepi_1_1UncertainValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Visitable.html">Visitable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Visitor.html">Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic visitor inspired by Fedor Pikus.  <a href="structepi_1_1Visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Visitor_3_01T_01_4.html">Visitor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1Visitor_3_01T_00_01Types_8_8_8_01_4.html">Visitor&lt; T, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structepi_1_1WorkRatio.html">WorkRatio</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classepi_1_1World.html">World</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The world of the simulation.  <a href="classepi_1_1World.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6b1a9c4fa2e196c5559ef49ec1a5853c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> = <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; <a class="el" href="structepi_1_1LockdownDate.html">LockdownDate</a>, <a class="el" href="structepi_1_1SocialEventRate.html">SocialEventRate</a>, <a class="el" href="structepi_1_1BasicShoppingRate.html">BasicShoppingRate</a>, <a class="el" href="structepi_1_1WorkRatio.html">WorkRatio</a>, <a class="el" href="structepi_1_1SchoolRatio.html">SchoolRatio</a> &gt;</td></tr>
<tr class="memdesc:a6b1a9c4fa2e196c5559ef49ec1a5853c"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters that control the migration between locations.  <a href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">More...</a><br /></td></tr>
<tr class="separator:a6b1a9c4fa2e196c5559ef49ec1a5853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72f9828b941664722d9bbcfb06b0661"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:ae72f9828b941664722d9bbcfb06b0661"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ae72f9828b941664722d9bbcfb06b0661">advance_expr_t</a> = decltype(std::declval&lt; Sim &gt;().advance(std::declval&lt; double &gt;()))</td></tr>
<tr class="memdesc:ae72f9828b941664722d9bbcfb06b0661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the return type of the <code>advance</code> member function of a type.  <a href="namespaceepi.html#ae72f9828b941664722d9bbcfb06b0661">More...</a><br /></td></tr>
<tr class="separator:ae72f9828b941664722d9bbcfb06b0661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cdc2b2829dc3bd19041971a6cf5a95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af5cdc2b2829dc3bd19041971a6cf5a95">ConstParameterDistributionVisitor</a> = <a class="el" href="structepi_1_1ConstVisitor.html">ConstVisitor</a>&lt; class <a class="el" href="classepi_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a>, class <a class="el" href="classepi_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a> &gt;</td></tr>
<tr class="separator:af5cdc2b2829dc3bd19041971a6cf5a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e98c1a8155e93a5806cfb554c16ec23"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a6e98c1a8155e93a5806cfb554c16ec23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a6e98c1a8155e93a5806cfb554c16ec23">CVPlainMatrixT</a> = typename <a class="el" href="structepi_1_1CVPlainMatrix.html">CVPlainMatrix</a>&lt; M &gt;::Type</td></tr>
<tr class="separator:a6e98c1a8155e93a5806cfb554c16ec23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e728d6aa323ae9211af40b1ea030abe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a7e728d6aa323ae9211af40b1ea030abe">DerivFunction</a> = std::function&lt; void(Eigen::Ref&lt; const Eigen::VectorXd &gt; y, double t, Eigen::Ref&lt; Eigen::VectorXd &gt; dydt)&gt;</td></tr>
<tr class="memdesc:a7e728d6aa323ae9211af40b1ea030abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template to be integrated.  <a href="namespaceepi.html#a7e728d6aa323ae9211af40b1ea030abe">More...</a><br /></td></tr>
<tr class="separator:a7e728d6aa323ae9211af40b1ea030abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f4be98ec89a4bda1a78544c1f970b4"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:a18f4be98ec89a4bda1a78544c1f970b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a18f4be98ec89a4bda1a78544c1f970b4">deserialize_t</a> = decltype(T::deserialize(std::declval&lt; IOContext &amp; &gt;()))</td></tr>
<tr class="separator:a18f4be98ec89a4bda1a78544c1f970b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605eb0c2d8ac500f6628f75dc4f86c66"><td class="memTemplParams" colspan="2">template&lt;class Int &gt; </td></tr>
<tr class="memitem:a605eb0c2d8ac500f6628f75dc4f86c66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a605eb0c2d8ac500f6628f75dc4f86c66">DiscreteDistribution</a> = <a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a>&lt; <a class="el" href="classepi_1_1DiscreteDistributionInPlace.html">DiscreteDistributionInPlace</a>&lt; Int &gt; &gt;</td></tr>
<tr class="memdesc:a605eb0c2d8ac500f6628f75dc4f86c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted discrete distribution  <a href="namespaceepi.html#a605eb0c2d8ac500f6628f75dc4f86c66">More...</a><br /></td></tr>
<tr class="separator:a605eb0c2d8ac500f6628f75dc4f86c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa11e9378f9ab3f969265bd89ee9b441"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaa11e9378f9ab3f969265bd89ee9b441"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aaa11e9378f9ab3f969265bd89ee9b441">eq_op_t</a> = decltype(std::declval&lt; T &gt;()==std::declval&lt; T &gt;())</td></tr>
<tr class="memdesc:aaa11e9378f9ab3f969265bd89ee9b441"><td class="mdescLeft">&#160;</td><td class="mdescRight">meta function to check type T for an existing equality comparison operator  <a href="namespaceepi.html#aaa11e9378f9ab3f969265bd89ee9b441">More...</a><br /></td></tr>
<tr class="separator:aaa11e9378f9ab3f969265bd89ee9b441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cac98c077908bc007398f4ad7b1529"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:aa0cac98c077908bc007398f4ad7b1529"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa0cac98c077908bc007398f4ad7b1529">eval_right_hand_side_expr_t</a> = decltype(std::declval&lt; const M &amp; &gt;().eval_right_hand_side(std::declval&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &gt;(), std::declval&lt; Eigen::Ref&lt; const Eigen::VectorXd &gt; &gt;(), std::declval&lt; double &gt;(), std::declval&lt; Eigen::Ref&lt; Eigen::VectorXd &gt; &gt;()))</td></tr>
<tr class="memdesc:aa0cac98c077908bc007398f4ad7b1529"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect the eval_right_hand_side member function of a compartment model.  <a href="namespaceepi.html#aa0cac98c077908bc007398f4ad7b1529">More...</a><br /></td></tr>
<tr class="separator:aa0cac98c077908bc007398f4ad7b1529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3758b0557953769d38a123a7a855d41"><td class="memTemplParams" colspan="2">template&lt;class Real &gt; </td></tr>
<tr class="memitem:ad3758b0557953769d38a123a7a855d41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad3758b0557953769d38a123a7a855d41">ExponentialDistribution</a> = <a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a>&lt; std::exponential_distribution&lt; Real &gt; &gt;</td></tr>
<tr class="memdesc:ad3758b0557953769d38a123a7a855d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted std::exponential_distribution.  <a href="namespaceepi.html#ad3758b0557953769d38a123a7a855d41">More...</a><br /></td></tr>
<tr class="separator:ad3758b0557953769d38a123a7a855d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eae9cbb50977de4b8bc824cb8cf300"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a68eae9cbb50977de4b8bc824cb8cf300"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a68eae9cbb50977de4b8bc824cb8cf300">get_infections_relative_expr_t</a> = decltype(<a class="el" href="namespaceepi.html#ac5aaa132a35ad0befebd665dac41fa7b">get_infections_relative</a>(std::declval&lt; const Sim &amp; &gt;(), std::declval&lt; double &gt;(), std::declval&lt; const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:a68eae9cbb50977de4b8bc824cb8cf300"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect a get_infections_relative function for the Model type.  <a href="namespaceepi.html#a68eae9cbb50977de4b8bc824cb8cf300">More...</a><br /></td></tr>
<tr class="separator:a68eae9cbb50977de4b8bc824cb8cf300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c87ebcafdf586f5425535acb8cebd3"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a79c87ebcafdf586f5425535acb8cebd3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a79c87ebcafdf586f5425535acb8cebd3">get_initial_values_expr_t</a> = decltype(std::declval&lt; Eigen::VectorXd &amp; &gt;()=std::declval&lt; const M &amp; &gt;().get_initial_values())</td></tr>
<tr class="memdesc:a79c87ebcafdf586f5425535acb8cebd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect the get_initial_values member function of a compartment model.  <a href="namespaceepi.html#a79c87ebcafdf586f5425535acb8cebd3">More...</a><br /></td></tr>
<tr class="separator:a79c87ebcafdf586f5425535acb8cebd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d04ecebca75c2bfb37be13f5c08c90"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:ac9d04ecebca75c2bfb37be13f5c08c90"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac9d04ecebca75c2bfb37be13f5c08c90">get_migration_factors_expr_t</a> = decltype(<a class="el" href="namespaceepi.html#a175a57f9e3ae1cb3286ee8fa12382b21">get_migration_factors</a>(std::declval&lt; const Sim &amp; &gt;(), std::declval&lt; double &gt;(), std::declval&lt; const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp; &gt;()))</td></tr>
<tr class="memdesc:ac9d04ecebca75c2bfb37be13f5c08c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">detect a get_migration_factors function for the Model type.  <a href="namespaceepi.html#ac9d04ecebca75c2bfb37be13f5c08c90">More...</a><br /></td></tr>
<tr class="separator:ac9d04ecebca75c2bfb37be13f5c08c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d0e3dfee3b53f13540bc1bc9dbe590"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa0d0e3dfee3b53f13540bc1bc9dbe590">GlobalInfectionParameters</a> = <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; <a class="el" href="structepi_1_1IncubationPeriod.html">IncubationPeriod</a>, <a class="el" href="structepi_1_1SusceptibleToExposedByCarrier.html">SusceptibleToExposedByCarrier</a>, <a class="el" href="structepi_1_1SusceptibleToExposedByInfected.html">SusceptibleToExposedByInfected</a>, <a class="el" href="structepi_1_1CarrierToInfected.html">CarrierToInfected</a>, <a class="el" href="structepi_1_1CarrierToRecovered.html">CarrierToRecovered</a>, <a class="el" href="structepi_1_1InfectedToRecovered.html">InfectedToRecovered</a>, <a class="el" href="structepi_1_1InfectedToSevere.html">InfectedToSevere</a>, <a class="el" href="structepi_1_1SevereToCritical.html">SevereToCritical</a>, <a class="el" href="structepi_1_1SevereToRecovered.html">SevereToRecovered</a>, <a class="el" href="structepi_1_1CriticalToDead.html">CriticalToDead</a>, <a class="el" href="structepi_1_1CriticalToRecovered.html">CriticalToRecovered</a>, <a class="el" href="structepi_1_1RecoveredToSusceptible.html">RecoveredToSusceptible</a>, <a class="el" href="structepi_1_1DetectInfection.html">DetectInfection</a> &gt;</td></tr>
<tr class="memdesc:aa0d0e3dfee3b53f13540bc1bc9dbe590"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters of the infection that are the same everywhere within the world.  <a href="namespaceepi.html#aa0d0e3dfee3b53f13540bc1bc9dbe590">More...</a><br /></td></tr>
<tr class="separator:aa0d0e3dfee3b53f13540bc1bc9dbe590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7d0606b016adcad0609edaeba41571"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3a7d0606b016adcad0609edaeba41571"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a3a7d0606b016adcad0609edaeba41571">has_apply_constraints_member_function</a> = <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespaceepi_1_1details.html#a937466781a102b4c3e09b35b11aaa509">details::apply_constraints_expr_t</a>, T &gt;</td></tr>
<tr class="memdesc:a3a7d0606b016adcad0609edaeba41571"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a apply_constraints function exists  <a href="namespaceepi.html#a3a7d0606b016adcad0609edaeba41571">More...</a><br /></td></tr>
<tr class="separator:a3a7d0606b016adcad0609edaeba41571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f523a014c9ab0d54aa44b016379e57"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab3f523a014c9ab0d54aa44b016379e57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab3f523a014c9ab0d54aa44b016379e57">has_check_constraints_member_function</a> = <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespaceepi_1_1details.html#ac5f7e9186cba72e908b4e625a080b054">details::check_constraints_expr_t</a>, T &gt;</td></tr>
<tr class="memdesc:ab3f523a014c9ab0d54aa44b016379e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a check_constraints function exists  <a href="namespaceepi.html#ab3f523a014c9ab0d54aa44b016379e57">More...</a><br /></td></tr>
<tr class="separator:ab3f523a014c9ab0d54aa44b016379e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af568a71f01950c9f9cff23e59571f1ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af568a71f01950c9f9cff23e59571f1ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a> = <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespaceepi.html#aaa11e9378f9ab3f969265bd89ee9b441">eq_op_t</a>, T &gt;</td></tr>
<tr class="separator:af568a71f01950c9f9cff23e59571f1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97485bd337bb3d17b03b77dae7a107d5"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a97485bd337bb3d17b03b77dae7a107d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a97485bd337bb3d17b03b77dae7a107d5">has_get_default_member_function</a> = <a class="el" href="structepi_1_1details_1_1has__get__default__member__function.html">details::has_get_default_member_function</a>&lt; T, void, Args... &gt;</td></tr>
<tr class="memdesc:a97485bd337bb3d17b03b77dae7a107d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a get_default function exists  <a href="namespaceepi.html#a97485bd337bb3d17b03b77dae7a107d5">More...</a><br /></td></tr>
<tr class="separator:a97485bd337bb3d17b03b77dae7a107d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab571ed7d1014cba00ba92c61dc5a729"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aab571ed7d1014cba00ba92c61dc5a729"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a> = <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespaceepi.html#a546d8de8b1e1ed49bc560b0c3e076153">ostream_op_expr_t</a>, T &gt;</td></tr>
<tr class="separator:aab571ed7d1014cba00ba92c61dc5a729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b1dbb8f2d81b0e5af433760fc156c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aec4b1dbb8f2d81b0e5af433760fc156c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aec4b1dbb8f2d81b0e5af433760fc156c">InterpolateResultT</a> = std::decay_t&lt; decltype(<a class="el" href="namespaceepi.html#a9dfb5f0f7703e75e9667ff4bedcf5e97">interpolate_simulation_result</a>(std::declval&lt; T &gt;()))&gt;</td></tr>
<tr class="memdesc:aec4b1dbb8f2d81b0e5af433760fc156c"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper template, type returned by overload interpolate_simulation_result(T t)  <a href="namespaceepi.html#aec4b1dbb8f2d81b0e5af433760fc156c">More...</a><br /></td></tr>
<tr class="separator:aec4b1dbb8f2d81b0e5af433760fc156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f5e00dd122b11fad06af0f2e72ee1a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a89f5e00dd122b11fad06af0f2e72ee1a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a> = boost::outcome_v2::unchecked&lt; T, <a class="el" href="classepi_1_1IOStatus.html">IOStatus</a> &gt;</td></tr>
<tr class="memdesc:a89f5e00dd122b11fad06af0f2e72ee1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value-or-error type for operations that return a value but can fail.  <a href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">More...</a><br /></td></tr>
<tr class="separator:a89f5e00dd122b11fad06af0f2e72ee1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec32ec82cdf215e82e31c870d65608cc"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:aec32ec82cdf215e82e31c870d65608cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aec32ec82cdf215e82e31c870d65608cc">is_compartment_model</a> = std::integral_constant&lt; bool,(<a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespaceepi.html#aa0cac98c077908bc007398f4ad7b1529">eval_right_hand_side_expr_t</a>, M &gt;::value &amp;&amp;<a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespaceepi.html#a79c87ebcafdf586f5425535acb8cebd3">get_initial_values_expr_t</a>, M &gt;::value)&gt;</td></tr>
<tr class="memdesc:aec32ec82cdf215e82e31c870d65608cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template meta function to check if a type is a valid compartment model.  <a href="namespaceepi.html#aec32ec82cdf215e82e31c870d65608cc">More...</a><br /></td></tr>
<tr class="separator:aec32ec82cdf215e82e31c870d65608cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff85b25e355a74c705c51c28bde8b94"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a0ff85b25e355a74c705c51c28bde8b94"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0ff85b25e355a74c705c51c28bde8b94">is_compartment_model_simulation</a> = std::integral_constant&lt; bool,(<a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespaceepi.html#ae72f9828b941664722d9bbcfb06b0661">advance_expr_t</a>, Sim &gt;::value &amp;&amp;<a class="el" href="namespaceepi.html#aec32ec82cdf215e82e31c870d65608cc">is_compartment_model</a>&lt; typename Sim::Model &gt;::value)&gt;</td></tr>
<tr class="memdesc:a0ff85b25e355a74c705c51c28bde8b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template meta function to check if a type is a compartment model simulation.  <a href="namespaceepi.html#a0ff85b25e355a74c705c51c28bde8b94">More...</a><br /></td></tr>
<tr class="separator:a0ff85b25e355a74c705c51c28bde8b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a90efeb8b830c7399e938725425fbd8"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a7a90efeb8b830c7399e938725425fbd8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a7a90efeb8b830c7399e938725425fbd8">is_container</a> = <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt; <a class="el" href="namespaceepi_1_1details.html#a123bb608d46e6515087c6098d2cc9b50">details::compare_iterators_t</a>, C &gt;</td></tr>
<tr class="memdesc:a7a90efeb8b830c7399e938725425fbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is std::true_type if C is a STL compatible container.  <a href="namespaceepi.html#a7a90efeb8b830c7399e938725425fbd8">More...</a><br /></td></tr>
<tr class="separator:a7a90efeb8b830c7399e938725425fbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ee8ed255776fe210e3202ac4bd1a4d"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a50ee8ed255776fe210e3202ac4bd1a4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a50ee8ed255776fe210e3202ac4bd1a4d">is_matrix_expression</a> = std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;</td></tr>
<tr class="memdesc:a50ee8ed255776fe210e3202ac4bd1a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template utility.  <a href="namespaceepi.html#a50ee8ed255776fe210e3202ac4bd1a4d">More...</a><br /></td></tr>
<tr class="separator:a50ee8ed255776fe210e3202ac4bd1a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13162531b7e44e0c336c8026d145565"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa13162531b7e44e0c336c8026d145565"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa13162531b7e44e0c336c8026d145565">is_no_default_init_tag</a> = std::is_same&lt; <a class="el" href="structepi_1_1NoDefaultInit.html">NoDefaultInit</a>, T &gt;</td></tr>
<tr class="separator:aa13162531b7e44e0c336c8026d145565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f48f3e7d3f0fb94f9957174efa2903e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0f48f3e7d3f0fb94f9957174efa2903e">LocalInfectionParameters</a> = <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; <a class="el" href="structepi_1_1EffectiveContacts.html">EffectiveContacts</a> &gt;</td></tr>
<tr class="memdesc:a0f48f3e7d3f0fb94f9957174efa2903e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters of the infection that depend on the location.  <a href="namespaceepi.html#a0f48f3e7d3f0fb94f9957174efa2903e">More...</a><br /></td></tr>
<tr class="separator:a0f48f3e7d3f0fb94f9957174efa2903e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f190cfe8f0c5c5d510179e8ca5c33d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a61f190cfe8f0c5c5d510179e8ca5c33d">MigrationCoefficientGroup</a> = <a class="el" href="classepi_1_1DampingMatrixExpressionGroup.html">DampingMatrixExpressionGroup</a>&lt; <a class="el" href="namespaceepi.html#a07f9e7d4ac440ba9752d0fb54e3d51d2">MigrationCoefficients</a> &gt;</td></tr>
<tr class="memdesc:a61f190cfe8f0c5c5d510179e8ca5c33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sum of time dependent migration coefficients.  <a href="namespaceepi.html#a61f190cfe8f0c5c5d510179e8ca5c33d">More...</a><br /></td></tr>
<tr class="separator:a61f190cfe8f0c5c5d510179e8ca5c33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f9e7d4ac440ba9752d0fb54e3d51d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a07f9e7d4ac440ba9752d0fb54e3d51d2">MigrationCoefficients</a> = <a class="el" href="classepi_1_1DampingMatrixExpression.html">DampingMatrixExpression</a>&lt; <a class="el" href="namespaceepi.html#a63fa4d5a798f1c6bf3d131245edd2f7b">VectorDampings</a> &gt;</td></tr>
<tr class="memdesc:a07f9e7d4ac440ba9752d0fb54e3d51d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">time dependent migration coefficients.  <a href="namespaceepi.html#a07f9e7d4ac440ba9752d0fb54e3d51d2">More...</a><br /></td></tr>
<tr class="separator:a07f9e7d4ac440ba9752d0fb54e3d51d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546d8de8b1e1ed49bc560b0c3e076153"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a546d8de8b1e1ed49bc560b0c3e076153"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a546d8de8b1e1ed49bc560b0c3e076153">ostream_op_expr_t</a> = decltype(std::declval&lt; std::ostream &amp; &gt;()&lt;&lt; std::declval&lt; T &gt;())</td></tr>
<tr class="memdesc:a546d8de8b1e1ed49bc560b0c3e076153"><td class="mdescLeft">&#160;</td><td class="mdescRight">meta function to check type T for an existing stream output operator "&lt;&lt;"  <a href="namespaceepi.html#a546d8de8b1e1ed49bc560b0c3e076153">More...</a><br /></td></tr>
<tr class="separator:a546d8de8b1e1ed49bc560b0c3e076153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614538fbd4acda827fea8ce8a10ca15e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a614538fbd4acda827fea8ce8a10ca15e">ParameterDistributionVisitor</a> = <a class="el" href="structepi_1_1Visitor.html">Visitor</a>&lt; class <a class="el" href="classepi_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a>, class <a class="el" href="classepi_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a> &gt;</td></tr>
<tr class="memdesc:a614538fbd4acda827fea8ce8a10ca15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a visitor class to visit all Parameter Distribution objects.  <a href="namespaceepi.html#a614538fbd4acda827fea8ce8a10ca15e">More...</a><br /></td></tr>
<tr class="separator:a614538fbd4acda827fea8ce8a10ca15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaf34550f501bb3ebc7e30b21f691a2"><td class="memTemplParams" colspan="2">template&lt;size_t I, class ParamSet &gt; </td></tr>
<tr class="memitem:aaaaf34550f501bb3ebc7e30b21f691a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aaaaf34550f501bb3ebc7e30b21f691a2">ParameterTag</a> = <a class="el" href="structepi_1_1details_1_1ParameterTag.html">details::ParameterTag</a>&lt; I, ParamSet &gt;</td></tr>
<tr class="memdesc:aaaaf34550f501bb3ebc7e30b21f691a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the the tag of the I-th parameter in a set  <a href="namespaceepi.html#aaaaf34550f501bb3ebc7e30b21f691a2">More...</a><br /></td></tr>
<tr class="separator:aaaaf34550f501bb3ebc7e30b21f691a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5971707e01729b665aac54c7161922f"><td class="memTemplParams" colspan="2">template&lt;size_t I, class ParamSet &gt; </td></tr>
<tr class="memitem:ad5971707e01729b665aac54c7161922f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad5971707e01729b665aac54c7161922f">ParameterTagT</a> = typename <a class="el" href="namespaceepi.html#aaaaf34550f501bb3ebc7e30b21f691a2">ParameterTag</a>&lt; I, ParamSet &gt;::Type</td></tr>
<tr class="separator:ad5971707e01729b665aac54c7161922f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c199d53d5376dd9714e6c391d49e81d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a6c199d53d5376dd9714e6c391d49e81d">SecirParamsBase</a> = <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; <a class="el" href="structepi_1_1StartDay.html">StartDay</a>,<a class="el" href="structepi_1_1Seasonality.html">Seasonality</a>,<a class="el" href="structepi_1_1ICUCapacity.html">ICUCapacity</a>,<a class="el" href="structepi_1_1TestAndTraceCapacity.html">TestAndTraceCapacity</a>,<a class="el" href="structepi_1_1ContactPatterns.html">ContactPatterns</a>,<a class="el" href="structepi_1_1DynamicNPIsInfected.html">DynamicNPIsInfected</a>,<a class="el" href="structepi_1_1IncubationTime.html">IncubationTime</a>,<a class="el" href="structepi_1_1InfectiousTimeMild.html">InfectiousTimeMild</a>,<a class="el" href="structepi_1_1InfectiousTimeAsymptomatic.html">InfectiousTimeAsymptomatic</a>,<a class="el" href="structepi_1_1SerialInterval.html">SerialInterval</a>,<a class="el" href="structepi_1_1HospitalizedToHomeTime.html">HospitalizedToHomeTime</a>,<a class="el" href="structepi_1_1HomeToHospitalizedTime.html">HomeToHospitalizedTime</a>,<a class="el" href="structepi_1_1HospitalizedToICUTime.html">HospitalizedToICUTime</a>,<a class="el" href="structepi_1_1ICUToHomeTime.html">ICUToHomeTime</a>,<a class="el" href="structepi_1_1ICUToDeathTime.html">ICUToDeathTime</a>,<a class="el" href="structepi_1_1InfectionProbabilityFromContact.html">InfectionProbabilityFromContact</a>,<a class="el" href="structepi_1_1RelativeCarrierInfectability.html">RelativeCarrierInfectability</a>,<a class="el" href="structepi_1_1AsymptoticCasesPerInfectious.html">AsymptoticCasesPerInfectious</a>,<a class="el" href="structepi_1_1RiskOfInfectionFromSympomatic.html">RiskOfInfectionFromSympomatic</a>,<a class="el" href="structepi_1_1MaxRiskOfInfectionFromSympomatic.html">MaxRiskOfInfectionFromSympomatic</a>,<a class="el" href="structepi_1_1HospitalizedCasesPerInfectious.html">HospitalizedCasesPerInfectious</a>,<a class="el" href="structepi_1_1ICUCasesPerHospitalized.html">ICUCasesPerHospitalized</a>,<a class="el" href="structepi_1_1DeathsPerHospitalized.html">DeathsPerHospitalized</a> &gt;</td></tr>
<tr class="separator:a6c199d53d5376dd9714e6c391d49e81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b893d23c35e69d8abb33b3ab79e07b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac3b893d23c35e69d8abb33b3ab79e07b">SeirParameters</a> = <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; <a class="el" href="structepi_1_1TransmissionRisk.html">TransmissionRisk</a>, <a class="el" href="structepi_1_1StageTimeIncubationInv.html">StageTimeIncubationInv</a>, <a class="el" href="structepi_1_1StageTimeInfectiousInv.html">StageTimeInfectiousInv</a>, <a class="el" href="structepi_1_1ContactFrequency.html">ContactFrequency</a> &gt;</td></tr>
<tr class="separator:ac3b893d23c35e69d8abb33b3ab79e07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5810f8faae7ca1509383c09026c03b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0b5810f8faae7ca1509383c09026c03b">SeirPopulations</a> = <a class="el" href="classepi_1_1Populations.html">Populations</a>&lt; <a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cba">SeirInfType</a> &gt;</td></tr>
<tr class="separator:a0b5810f8faae7ca1509383c09026c03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d78f82897c5bcd59f9a1a4dc60db35"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:a66d78f82897c5bcd59f9a1a4dc60db35"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a66d78f82897c5bcd59f9a1a4dc60db35">serialize_t</a> = decltype(std::declval&lt; T &gt;().<a class="el" href="namespaceepi.html#ab7695ed10dce7f77ba45a6a208aa801c">serialize</a>(std::declval&lt; IOContext &amp; &gt;()))</td></tr>
<tr class="separator:a66d78f82897c5bcd59f9a1a4dc60db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94de3505cb1d61b182329474c9d5e444"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a94de3505cb1d61b182329474c9d5e444">SquareDamping</a> = <a class="el" href="classepi_1_1Damping.html">Damping</a>&lt; <a class="el" href="classepi_1_1SquareMatrixShape.html">SquareMatrixShape</a> &gt;</td></tr>
<tr class="memdesc:a94de3505cb1d61b182329474c9d5e444"><td class="mdescLeft">&#160;</td><td class="mdescRight">aliases for common damping specializations.  <a href="namespaceepi.html#a94de3505cb1d61b182329474c9d5e444">More...</a><br /></td></tr>
<tr class="separator:a94de3505cb1d61b182329474c9d5e444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95892d0984ef6d2c218fb2f6ee278b22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a95892d0984ef6d2c218fb2f6ee278b22">SquareDampings</a> = <a class="el" href="classepi_1_1Dampings.html">Dampings</a>&lt; <a class="el" href="namespaceepi.html#a94de3505cb1d61b182329474c9d5e444">SquareDamping</a> &gt;</td></tr>
<tr class="separator:a95892d0984ef6d2c218fb2f6ee278b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c8b9491165ac4a30ac7f9208975056"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad6c8b9491165ac4a30ac7f9208975056"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a> = boost::outcome_v2::in_place_type_t&lt; T &gt;</td></tr>
<tr class="memdesc:ad6c8b9491165ac4a30ac7f9208975056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that is used for overload resolution.  <a href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">More...</a><br /></td></tr>
<tr class="separator:ad6c8b9491165ac4a30ac7f9208975056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c5e3fea7f9fc3b2ebc19ffdd1c5e78"><td class="memTemplParams" colspan="2">template&lt;class Real &gt; </td></tr>
<tr class="memitem:a32c5e3fea7f9fc3b2ebc19ffdd1c5e78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a32c5e3fea7f9fc3b2ebc19ffdd1c5e78">UniformDistribution</a> = <a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a>&lt; std::uniform_real_distribution&lt; Real &gt; &gt;</td></tr>
<tr class="memdesc:a32c5e3fea7f9fc3b2ebc19ffdd1c5e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted uniform_real_distribution.  <a href="namespaceepi.html#a32c5e3fea7f9fc3b2ebc19ffdd1c5e78">More...</a><br /></td></tr>
<tr class="separator:a32c5e3fea7f9fc3b2ebc19ffdd1c5e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500acd4e2d9dcca2e2c3a77d3c99e4b3"><td class="memTemplParams" colspan="2">template&lt;class Int &gt; </td></tr>
<tr class="memitem:a500acd4e2d9dcca2e2c3a77d3c99e4b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a500acd4e2d9dcca2e2c3a77d3c99e4b3">UniformIntDistribution</a> = <a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a>&lt; std::uniform_int_distribution&lt; Int &gt; &gt;</td></tr>
<tr class="memdesc:a500acd4e2d9dcca2e2c3a77d3c99e4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">adapted std::uniform_int_distribution.  <a href="namespaceepi.html#a500acd4e2d9dcca2e2c3a77d3c99e4b3">More...</a><br /></td></tr>
<tr class="separator:a500acd4e2d9dcca2e2c3a77d3c99e4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca617f209ac030250a7a2ec56b8fee3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aeca617f209ac030250a7a2ec56b8fee3">VectorDamping</a> = <a class="el" href="classepi_1_1Damping.html">Damping</a>&lt; <a class="el" href="classepi_1_1ColumnVectorShape.html">ColumnVectorShape</a> &gt;</td></tr>
<tr class="separator:aeca617f209ac030250a7a2ec56b8fee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fa4d5a798f1c6bf3d131245edd2f7b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a63fa4d5a798f1c6bf3d131245edd2f7b">VectorDampings</a> = <a class="el" href="classepi_1_1Dampings.html">Dampings</a>&lt; <a class="el" href="namespaceepi.html#aeca617f209ac030250a7a2ec56b8fee3">VectorDamping</a> &gt;</td></tr>
<tr class="separator:a63fa4d5a798f1c6bf3d131245edd2f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804ae3dfeddc7fe4c03beddd3feb4307"><td class="memTemplParams" colspan="2">template&lt;class Derived &gt; </td></tr>
<tr class="memitem:a804ae3dfeddc7fe4c03beddd3feb4307"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a804ae3dfeddc7fe4c03beddd3feb4307">VisitableParameterDistribution</a> = <a class="el" href="structepi_1_1Visitable.html">Visitable</a>&lt; Derived, class <a class="el" href="classepi_1_1ParameterDistribution.html">ParameterDistribution</a>, <a class="el" href="namespaceepi.html#a614538fbd4acda827fea8ce8a10ca15e">ParameterDistributionVisitor</a>, <a class="el" href="namespaceepi.html#af5cdc2b2829dc3bd19041971a6cf5a95">ConstParameterDistributionVisitor</a> &gt;</td></tr>
<tr class="separator:a804ae3dfeddc7fe4c03beddd3feb4307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f3bdea77e1a3e6eabe0b7f3b821382"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a84f3bdea77e1a3e6eabe0b7f3b821382"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a84f3bdea77e1a3e6eabe0b7f3b821382">void_t</a> = typename <a class="el" href="structepi_1_1details_1_1make__void.html">details::make_void</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:a84f3bdea77e1a3e6eabe0b7f3b821382"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility for meta programming that produces void for any valid type.  <a href="namespaceepi.html#a84f3bdea77e1a3e6eabe0b7f3b821382">More...</a><br /></td></tr>
<tr class="separator:a84f3bdea77e1a3e6eabe0b7f3b821382"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a784fce71eb260f60a05f83af3b93b29f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29f">AbmAgeGroup</a> { <br />
&#160;&#160;<a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29faecdef1978b0426a4dbce2482e4d992c0">AbmAgeGroup::Age0to4</a> = 0, 
<a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29fa0e635bc20a1ebd1d39528e24ad180ea6">AbmAgeGroup::Age5to14</a>, 
<a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29fad94c53cbd84e5bb40ac92d58ecf410e1">AbmAgeGroup::Age15to34</a>, 
<a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29fa1af7e3664451c7caa568fdc0fe9bbea7">AbmAgeGroup::Age35to59</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29fa256d02bd24303e832b43bc2c45b1ea8e">AbmAgeGroup::Age60to79</a>, 
<a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29fadc550a7d96fee29c927fc5f8200a312a">AbmAgeGroup::Age80plus</a>, 
<a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29fae93f994f01c537c4e2f7d8528c3eb5e9">AbmAgeGroup::Count</a>
<br />
 }</td></tr>
<tr class="memdesc:a784fce71eb260f60a05f83af3b93b29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">age groups like RKI.  <a href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29f">More...</a><br /></td></tr>
<tr class="separator:a784fce71eb260f60a05f83af3b93b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17593cd975761f387cc5b33364da2aae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aae">InfectionState</a> { <br />
&#160;&#160;<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea494bf3eaa390dc405dd04ed1c8c99311">InfectionState::Susceptible</a> = 0, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaeaa54eecd5041d37f5c8443e0ee91e241a">InfectionState::Exposed</a>, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea914419aa32f04011357d3b604a86d7eb">InfectionState::Carrier</a>, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea36b9ceab1f9b08d33edcf6938502e668">InfectionState::Infected_Detected</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaeaae58548244582c05ad9a2b71d73b9fa2">InfectionState::Infected_Undetected</a>, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea58bfe3d6d7066460b884407b8aa3e6ff">InfectionState::Infected_Severe</a>, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaeaf6ffec455b098e0fd677c127981b5941">InfectionState::Infected_Critical</a>, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea24461bbbf6767efaceb04659c41b24cb">InfectionState::Recovered_Carrier</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaeadbfd2bf86aae96cb44cc667248dace3a">InfectionState::Recovered_Infected</a>, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea183b62c7f067711f9c5a54913c054617">InfectionState::Dead</a>, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaeae93f994f01c537c4e2f7d8528c3eb5e9">InfectionState::Count</a>, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea494bf3eaa390dc405dd04ed1c8c99311">InfectionState::Susceptible</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaeaa54eecd5041d37f5c8443e0ee91e241a">InfectionState::Exposed</a> = 1, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea914419aa32f04011357d3b604a86d7eb">InfectionState::Carrier</a> = 2, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaeae11a453510398112e5dba69d300da48b">InfectionState::Infected</a> = 3, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea6c8cd990c3a6f78e53faa743bee2850b">InfectionState::Hospitalized</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea26bf7a7e68c0acc2c819ec1621630389">InfectionState::ICU</a> = 5, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea5c4c4cf7bbab0d76fe61420aee14a5ca">InfectionState::Recovered</a> = 6, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaea183b62c7f067711f9c5a54913c054617">InfectionState::Dead</a> = 7, 
<a class="el" href="namespaceepi.html#a17593cd975761f387cc5b33364da2aaeae93f994f01c537c4e2f7d8528c3eb5e9">InfectionState::Count</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:a17593cd975761f387cc5b33364da2aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The InfectionState enum describes the possible categories for the infectious state of persons.  <a href="namespaceepi.html#a17593cd975761f387cc5b33364da2aae">More...</a><br /></td></tr>
<tr class="separator:a17593cd975761f387cc5b33364da2aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa085820f5ddc6774e7591ec0b5305092"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092">InfectionState</a> : std::uint32_t { <br />
&#160;&#160;<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a494bf3eaa390dc405dd04ed1c8c99311">InfectionState::Susceptible</a> = 0, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092aa54eecd5041d37f5c8443e0ee91e241a">InfectionState::Exposed</a>, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a914419aa32f04011357d3b604a86d7eb">InfectionState::Carrier</a>, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a36b9ceab1f9b08d33edcf6938502e668">InfectionState::Infected_Detected</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092aae58548244582c05ad9a2b71d73b9fa2">InfectionState::Infected_Undetected</a>, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a58bfe3d6d7066460b884407b8aa3e6ff">InfectionState::Infected_Severe</a>, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092af6ffec455b098e0fd677c127981b5941">InfectionState::Infected_Critical</a>, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a24461bbbf6767efaceb04659c41b24cb">InfectionState::Recovered_Carrier</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092adbfd2bf86aae96cb44cc667248dace3a">InfectionState::Recovered_Infected</a>, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a183b62c7f067711f9c5a54913c054617">InfectionState::Dead</a>, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092ae93f994f01c537c4e2f7d8528c3eb5e9">InfectionState::Count</a>, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a494bf3eaa390dc405dd04ed1c8c99311">InfectionState::Susceptible</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092aa54eecd5041d37f5c8443e0ee91e241a">InfectionState::Exposed</a> = 1, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a914419aa32f04011357d3b604a86d7eb">InfectionState::Carrier</a> = 2, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092ae11a453510398112e5dba69d300da48b">InfectionState::Infected</a> = 3, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a6c8cd990c3a6f78e53faa743bee2850b">InfectionState::Hospitalized</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a26bf7a7e68c0acc2c819ec1621630389">InfectionState::ICU</a> = 5, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a5c4c4cf7bbab0d76fe61420aee14a5ca">InfectionState::Recovered</a> = 6, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092a183b62c7f067711f9c5a54913c054617">InfectionState::Dead</a> = 7, 
<a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092ae93f994f01c537c4e2f7d8528c3eb5e9">InfectionState::Count</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:aa085820f5ddc6774e7591ec0b5305092"><td class="mdescLeft">&#160;</td><td class="mdescRight">infection state in ABM.  <a href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092">More...</a><br /></td></tr>
<tr class="separator:aa085820f5ddc6774e7591ec0b5305092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf67eb2c517123112248a0025645724"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724">IOFlags</a> { <a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a> = 0, 
<a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724af2b4bcefd5e7aa65f7f3d6f9d81432cb">IOF_OmitDistributions</a> = 1 &lt;&lt; 0, 
<a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a51a573ce09fe1f8dc1ccbcfacf3ba115">IOF_OmitValues</a> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="memdesc:a1bf67eb2c517123112248a0025645724"><td class="mdescLeft">&#160;</td><td class="mdescRight">flags to determine the behavior of the serialization process.  <a href="namespaceepi.html#a1bf67eb2c517123112248a0025645724">More...</a><br /></td></tr>
<tr class="separator:a1bf67eb2c517123112248a0025645724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabd8b3f600e98668b14d2d891526943"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> : std::uint32_t { <br />
&#160;&#160;<a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943a8cf04a9734132302f96da8e113e80ce5">LocationType::Home</a> = 0, 
<a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943a955cd8691ca89a6baa6ea10c7787e604">LocationType::School</a>, 
<a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943a0f9263536b9fc61ada745644735bfd8f">LocationType::Work</a>, 
<a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943a53ceef26ee8557fa2446a2596daed5c0">LocationType::SocialEvent</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943a0c09a8f523b937dae1ff7e3588566465">LocationType::BasicsShop</a>, 
<a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943acc2ab63fd3eb564be64b4f21bd083bc7">LocationType::Hospital</a>, 
<a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943a26bf7a7e68c0acc2c819ec1621630389">LocationType::ICU</a>, 
<a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943ae93f994f01c537c4e2f7d8528c3eb5e9">LocationType::Count</a>
<br />
 }</td></tr>
<tr class="memdesc:adabd8b3f600e98668b14d2d891526943"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a location.  <a href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">More...</a><br /></td></tr>
<tr class="separator:adabd8b3f600e98668b14d2d891526943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d44f54b29b6a8e746bef68135a3ac60"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a> { <br />
&#160;&#160;<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60a04a75036e9d520bb983c5ed03b8d0182">LogLevel::trace</a>, 
<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60aad42f6697b035b7580e4fef93be20b4d">LogLevel::debug</a>, 
<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60acaf9b6b99962bf5c2264824231d7a40c">LogLevel::info</a>, 
<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60a1ea4c3ab05ee0c6d4de30740443769cb">LogLevel::warn</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60a56bd7107802ebe56c6918992f0608ec6">LogLevel::err</a>, 
<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60a7e85bcb66fb9a809d5ab4f62a8b8bea8">LogLevel::critical</a>, 
<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60a3262d48df5d75e3452f0f16b313b7808">LogLevel::off</a>
<br />
 }</td></tr>
<tr class="separator:a4d44f54b29b6a8e746bef68135a3ac60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff5db7abe78b78015732f96de311cba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cba">SeirInfType</a> { <br />
&#160;&#160;<a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cbaa5dbc98dcc983a70728bd082d1a47546e">SeirInfType::S</a>, 
<a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cbaa3a3ea00cfc35332cedf6e5e9a32e94da">SeirInfType::E</a>, 
<a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cbaadd7536794b63bf90eccfd37f9b147d7f">SeirInfType::I</a>, 
<a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cbaae1e1d3d40573127e9ee0480caf1283d6">SeirInfType::R</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cbaae93f994f01c537c4e2f7d8528c3eb5e9">SeirInfType::Count</a> = 4
<br />
 }</td></tr>
<tr class="separator:a0ff5db7abe78b78015732f96de311cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e26c2aefb564c12224c2dd16b1ba8ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ce">StatusCode</a> { <br />
&#160;&#160;<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ceae0aa021e21dddbd6d8cecec71e9cf564">StatusCode::OK</a> = 0, 
<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ceabfaef30f1c8011c5cefa38ae470fb7aa">StatusCode::UnknownError</a> = 1, 
<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8cea365b2699d38b61ef4b4c8a1066c8468f">StatusCode::OutOfRange</a>, 
<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8cea223e81e8afa42c41346a6696560ecc7b">StatusCode::InvalidValue</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ceade9a4832789ef70d5f9bee2a83345e8a">StatusCode::InvalidFileFormat</a>, 
<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ceaa645e4cfc8d16be330607ad52aec5f98">StatusCode::KeyNotFound</a>, 
<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ceac85f85f7c13ed006eed130ec183aa810">StatusCode::InvalidType</a>, 
<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8cea2767828026039e8ba7b38973cbb701f2">StatusCode::FileNotFound</a>
<br />
 }</td></tr>
<tr class="memdesc:a1e26c2aefb564c12224c2dd16b1ba8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">code to indicate the result of an operation.  <a href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ce">More...</a><br /></td></tr>
<tr class="separator:a1e26c2aefb564c12224c2dd16b1ba8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af72dbc8ce3e0a9d0e576f9cfe6f5fed4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af72dbc8ce3e0a9d0e576f9cfe6f5fed4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af72dbc8ce3e0a9d0e576f9cfe6f5fed4">abs_max</a> (T v1, T v2)</td></tr>
<tr class="memdesc:af72dbc8ce3e0a9d0e576f9cfe6f5fed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum absolute value of two numbers.  <a href="namespaceepi.html#af72dbc8ce3e0a9d0e576f9cfe6f5fed4">More...</a><br /></td></tr>
<tr class="separator:af72dbc8ce3e0a9d0e576f9cfe6f5fed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a2504363f09ad496faf88547925bef"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class F , class... T&gt; </td></tr>
<tr class="memitem:a15a2504363f09ad496faf88547925bef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi_1_1details.html#a3fac1957f2e080c3a4198e55f33a434e">details::ApplyResultT</a>&lt; F, T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a15a2504363f09ad496faf88547925bef">apply</a> (IOContext &amp;io, F f, const <a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; T &gt; &amp;... rs)</td></tr>
<tr class="memdesc:a15a2504363f09ad496faf88547925bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a function with zero or more unpacked IOResults as arguments.  <a href="namespaceepi.html#a15a2504363f09ad496faf88547925bef">More...</a><br /></td></tr>
<tr class="separator:a15a2504363f09ad496faf88547925bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c57f3648db1d2f23fa373b1c2deab2c"><td class="memTemplParams" colspan="2">template&lt;class DampingExpression , class DampingSamplings , class F &gt; </td></tr>
<tr class="memitem:a4c57f3648db1d2f23fa373b1c2deab2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a4c57f3648db1d2f23fa373b1c2deab2c">apply_dampings</a> (DampingExpression &amp;damping_expression, const DampingSamplings &amp;dampings, F make_matrix)</td></tr>
<tr class="memdesc:a4c57f3648db1d2f23fa373b1c2deab2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">add sampled dampings to a damping expression.  <a href="namespaceepi.html#a4c57f3648db1d2f23fa373b1c2deab2c">More...</a><br /></td></tr>
<tr class="separator:a4c57f3648db1d2f23fa373b1c2deab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e20cf9e16e9bac7d54b7b90bcd1b6a3"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:a0e20cf9e16e9bac7d54b7b90bcd1b6a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0e20cf9e16e9bac7d54b7b90bcd1b6a3">apply_migration</a> (double t, double dt, <a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a> &amp;migrationEdge, <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;node_from, <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;node_to)</td></tr>
<tr class="memdesc:a0e20cf9e16e9bac7d54b7b90bcd1b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge functor for migration simulation.  <a href="namespaceepi.html#a0e20cf9e16e9bac7d54b7b90bcd1b6a3">More...</a><br /></td></tr>
<tr class="separator:a0e20cf9e16e9bac7d54b7b90bcd1b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbec4d09b91db02d1a5304e92933f3d4"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:abbec4d09b91db02d1a5304e92933f3d4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#abbec4d09b91db02d1a5304e92933f3d4">begin</a> (const M &amp;m)</td></tr>
<tr class="memdesc:abbec4d09b91db02d1a5304e92933f3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a const iterator to first element of the matrix m.  <a href="namespaceepi.html#abbec4d09b91db02d1a5304e92933f3d4">More...</a><br /></td></tr>
<tr class="separator:abbec4d09b91db02d1a5304e92933f3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e8b6a0525b440b6fcc4c958e4eb4ef"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a08e8b6a0525b440b6fcc4c958e4eb4ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceepi.html#a9deae6f690facc4fe4d3d3641c1f0458">conjunction_v</a>&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;, <a class="el" href="namespaceepi_1_1details.html#addd30df2f588966f391bf5a9f25e3418">details::IsElementReference</a>&lt; M &gt; &gt;, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, false &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a08e8b6a0525b440b6fcc4c958e4eb4ef">begin</a> (M &amp;m)</td></tr>
<tr class="memdesc:a08e8b6a0525b440b6fcc4c958e4eb4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-const iterator to first element of the matrix m.  <a href="namespaceepi.html#a08e8b6a0525b440b6fcc4c958e4eb4ef">More...</a><br /></td></tr>
<tr class="separator:a08e8b6a0525b440b6fcc4c958e4eb4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea232b41c2d92933cb0907bd5ec59a81"><td class="memTemplParams" colspan="2">template&lt;class Sim , class  = std::enable_if_t&lt;is_compartment_model_simulation&lt;Sim&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aea232b41c2d92933cb0907bd5ec59a81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aea232b41c2d92933cb0907bd5ec59a81">calculate_migration_returns</a> (Eigen::Ref&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;::Vector &gt; migrated, const Sim &amp;sim, Eigen::Ref&lt; const <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;::Vector &gt; total, double t, double dt)</td></tr>
<tr class="memdesc:aea232b41c2d92933cb0907bd5ec59a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust number of migrated people when they return according to the model.  <a href="namespaceepi.html#aea232b41c2d92933cb0907bd5ec59a81">More...</a><br /></td></tr>
<tr class="separator:aea232b41c2d92933cb0907bd5ec59a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661a5a85ffb891dc858c47286f4ff992"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a661a5a85ffb891dc858c47286f4ff992"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a661a5a85ffb891dc858c47286f4ff992">cbegin</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a661a5a85ffb891dc858c47286f4ff992"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a const iterator to first element of the matrix m.  <a href="namespaceepi.html#a661a5a85ffb891dc858c47286f4ff992">More...</a><br /></td></tr>
<tr class="separator:a661a5a85ffb891dc858c47286f4ff992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ae626c0e36715b86bc35ccbe5b5612"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a17ae626c0e36715b86bc35ccbe5b5612"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a17ae626c0e36715b86bc35ccbe5b5612">cend</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a17ae626c0e36715b86bc35ccbe5b5612"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-const end iterator for the matrix m.  <a href="namespaceepi.html#a17ae626c0e36715b86bc35ccbe5b5612">More...</a><br /></td></tr>
<tr class="separator:a17ae626c0e36715b86bc35ccbe5b5612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ddd084d167b1bc6933072ad6cb3d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a19ddd084d167b1bc6933072ad6cb3d34">close_social_events</a> (<a class="el" href="classepi_1_1TimePoint.html">TimePoint</a> t_begin, double p, <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;params)</td></tr>
<tr class="memdesc:a19ddd084d167b1bc6933072ad6cb3d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">During lockdown people join social events less often.  <a href="namespaceepi.html#a19ddd084d167b1bc6933072ad6cb3d34">More...</a><br /></td></tr>
<tr class="separator:a19ddd084d167b1bc6933072ad6cb3d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a579d7464e37419ca1df9411caee4ae"><td class="memTemplParams" colspan="2">template&lt;class Iter , class Pred &gt; </td></tr>
<tr class="memitem:a5a579d7464e37419ca1df9411caee4ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a5a579d7464e37419ca1df9411caee4ae">contains</a> (Iter b, Iter e, Pred p)</td></tr>
<tr class="memdesc:a5a579d7464e37419ca1df9411caee4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if there is an element in this range that matches a predicate  <a href="namespaceepi.html#a5a579d7464e37419ca1df9411caee4ae">More...</a><br /></td></tr>
<tr class="separator:a5a579d7464e37419ca1df9411caee4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5123237a88879be47114904097da2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a6b5123237a88879be47114904097da2c">count_lines</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a6b5123237a88879be47114904097da2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts lines of txt file.  <a href="namespaceepi.html#a6b5123237a88879be47114904097da2c">More...</a><br /></td></tr>
<tr class="separator:a6b5123237a88879be47114904097da2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67d2d9cff491983eb7023fd7b8120d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af67d2d9cff491983eb7023fd7b8120d0">create_directory</a> (std::string const  &amp;rel_path)</td></tr>
<tr class="memdesc:af67d2d9cff491983eb7023fd7b8120d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory in the file system.  <a href="namespaceepi.html#af67d2d9cff491983eb7023fd7b8120d0">More...</a><br /></td></tr>
<tr class="separator:af67d2d9cff491983eb7023fd7b8120d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7ec077532895e9729cc5ae46470dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0f7ec077532895e9729cc5ae46470dd9">create_directory</a> (std::string const  &amp;rel_path, std::string &amp;abs_path)</td></tr>
<tr class="memdesc:a0f7ec077532895e9729cc5ae46470dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory in the file system.  <a href="namespaceepi.html#a0f7ec077532895e9729cc5ae46470dd9">More...</a><br /></td></tr>
<tr class="separator:a0f7ec077532895e9729cc5ae46470dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1756628093347c730580c8fb835dd620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a1756628093347c730580c8fb835dd620">days</a> (int days)</td></tr>
<tr class="memdesc:a1756628093347c730580c8fb835dd620"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a <a class="el" href="classepi_1_1TimeSpan.html" title="a duration of time.">TimeSpan</a> with a specified number of days.  <a href="namespaceepi.html#a1756628093347c730580c8fb835dd620">More...</a><br /></td></tr>
<tr class="separator:a1756628093347c730580c8fb835dd620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e10d63305d29ed86d6fa016006dd52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac8e10d63305d29ed86d6fa016006dd52">DECL_TYPESAFE</a> (int, DampingLevel)</td></tr>
<tr class="memdesc:ac8e10d63305d29ed86d6fa016006dd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer damping level.  <a href="namespaceepi.html#ac8e10d63305d29ed86d6fa016006dd52">More...</a><br /></td></tr>
<tr class="separator:ac8e10d63305d29ed86d6fa016006dd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a12e1749121702a37fd801fcef335e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a1a12e1749121702a37fd801fcef335e8">DECL_TYPESAFE</a> (int, DampingType)</td></tr>
<tr class="memdesc:a1a12e1749121702a37fd801fcef335e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer damping type.  <a href="namespaceepi.html#a1a12e1749121702a37fd801fcef335e8">More...</a><br /></td></tr>
<tr class="separator:a1a12e1749121702a37fd801fcef335e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e11480551689fac0a957df08e757bf9"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:a9e11480551689fac0a957df08e757bf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a9e11480551689fac0a957df08e757bf9">deserialize</a> (IOContext &amp;io, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; T &gt; tag)</td></tr>
<tr class="memdesc:a9e11480551689fac0a957df08e757bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores an object from the data stored in an IO context.  <a href="namespaceepi.html#a9e11480551689fac0a957df08e757bf9">More...</a><br /></td></tr>
<tr class="separator:a9e11480551689fac0a957df08e757bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d51a7c94e53fd2cc4ecd3ace974a59f"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class Container , std::enable_if_t&lt;(is_container&lt; Container &gt;::value &amp;&amp;!is_expression_valid&lt; serialize_t, IOContext, Container &gt;::value), void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a1d51a7c94e53fd2cc4ecd3ace974a59f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a1d51a7c94e53fd2cc4ecd3ace974a59f">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; Container &gt;)</td></tr>
<tr class="memdesc:a1d51a7c94e53fd2cc4ecd3ace974a59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize an STL compatible container.  <a href="namespaceepi.html#a1d51a7c94e53fd2cc4ecd3ace974a59f">More...</a><br /></td></tr>
<tr class="separator:a1d51a7c94e53fd2cc4ecd3ace974a59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa414af8f1af5059823405afa21c7269a"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class E , std::enable_if_t&lt; std::is_enum&lt; E &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aa414af8f1af5059823405afa21c7269a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa414af8f1af5059823405afa21c7269a">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; E &gt;)</td></tr>
<tr class="memdesc:aa414af8f1af5059823405afa21c7269a"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize an enum value from its underlying type.  <a href="namespaceepi.html#aa414af8f1af5059823405afa21c7269a">More...</a><br /></td></tr>
<tr class="separator:aa414af8f1af5059823405afa21c7269a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab553ce68883355a0bb6b03264d8b3ab5"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class M , std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ab553ce68883355a0bb6b03264d8b3ab5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab553ce68883355a0bb6b03264d8b3ab5">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; M &gt;)</td></tr>
<tr class="memdesc:ab553ce68883355a0bb6b03264d8b3ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize an Eigen matrix.  <a href="namespaceepi.html#ab553ce68883355a0bb6b03264d8b3ab5">More...</a><br /></td></tr>
<tr class="separator:ab553ce68883355a0bb6b03264d8b3ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d8a6e4671f2b07ef97b87f9572f81a"><td class="memTemplParams" colspan="2">template&lt;class IOContext &gt; </td></tr>
<tr class="memitem:a98d8a6e4671f2b07ef97b87f9572f81a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; std::shared_ptr&lt; <a class="el" href="classepi_1_1ParameterDistribution.html">ParameterDistribution</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a98d8a6e4671f2b07ef97b87f9572f81a">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; std::shared_ptr&lt; <a class="el" href="classepi_1_1ParameterDistribution.html">ParameterDistribution</a> &gt;&gt;)</td></tr>
<tr class="memdesc:a98d8a6e4671f2b07ef97b87f9572f81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize a parameter distribution as a shared_ptr.  <a href="namespaceepi.html#a98d8a6e4671f2b07ef97b87f9572f81a">More...</a><br /></td></tr>
<tr class="separator:a98d8a6e4671f2b07ef97b87f9572f81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08113f6af9b3a80a22d62a320269b6c9"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T , std::enable_if_t&lt; is_expression_valid&lt; deserialize_t, IOContext, T &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a08113f6af9b3a80a22d62a320269b6c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a08113f6af9b3a80a22d62a320269b6c9">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; T &gt;)</td></tr>
<tr class="memdesc:a08113f6af9b3a80a22d62a320269b6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize an object that has a deserialize(io) static member function.  <a href="namespaceepi.html#a08113f6af9b3a80a22d62a320269b6c9">More...</a><br /></td></tr>
<tr class="separator:a08113f6af9b3a80a22d62a320269b6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc4606a640125fdd72e78127ad0394"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class Tup , class  = std::enable_if_t&lt;is_expression_valid&lt;details::tuple_size_value_t, Tup&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:abffc4606a640125fdd72e78127ad0394"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; Tup &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#abffc4606a640125fdd72e78127ad0394">deserialize_internal</a> (IOContext &amp;io, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; Tup &gt; tag)</td></tr>
<tr class="memdesc:abffc4606a640125fdd72e78127ad0394"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize a tuple-like object, e.g.  <a href="namespaceepi.html#abffc4606a640125fdd72e78127ad0394">More...</a><br /></td></tr>
<tr class="separator:abffc4606a640125fdd72e78127ad0394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40986136d1fe79d33178f311cbf9e68"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad40986136d1fe79d33178f311cbf9e68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad40986136d1fe79d33178f311cbf9e68">deserialize_json</a> (const Json::Value &amp;js, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; T &gt; tag, int flags=<a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a>)</td></tr>
<tr class="memdesc:ad40986136d1fe79d33178f311cbf9e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object from json.  <a href="namespaceepi.html#ad40986136d1fe79d33178f311cbf9e68">More...</a><br /></td></tr>
<tr class="separator:ad40986136d1fe79d33178f311cbf9e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6aa17aa8f8a27498436cde19967d84e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa6aa17aa8f8a27498436cde19967d84e">draw_sample</a> (<a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;model)</td></tr>
<tr class="memdesc:aa6aa17aa8f8a27498436cde19967d84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a sample from <a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> parameter distributions and stores sample values as <a class="el" href="classepi_1_1SecirParams.html" title="Parameters of an age-resolved SECIR/SECIHURD model.">SecirParams</a> parameter values (cf.  <a href="namespaceepi.html#aa6aa17aa8f8a27498436cde19967d84e">More...</a><br /></td></tr>
<tr class="separator:aa6aa17aa8f8a27498436cde19967d84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629645f6258a89bbdd5111b36a2f1680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a629645f6258a89bbdd5111b36a2f1680">draw_sample_demographics</a> (<a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;model)</td></tr>
<tr class="memdesc:a629645f6258a89bbdd5111b36a2f1680"><td class="mdescLeft">&#160;</td><td class="mdescRight">draws a sample from the specified distributions for all parameters related to the demographics, e.g.  <a href="namespaceepi.html#a629645f6258a89bbdd5111b36a2f1680">More...</a><br /></td></tr>
<tr class="separator:a629645f6258a89bbdd5111b36a2f1680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47365e82d9077f65082ade2212f6b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa47365e82d9077f65082ade2212f6b12">draw_sample_infection</a> (<a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;model)</td></tr>
<tr class="memdesc:aa47365e82d9077f65082ade2212f6b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">draws a sample from the specified distributions for all parameters related to the infection.  <a href="namespaceepi.html#aa47365e82d9077f65082ade2212f6b12">More...</a><br /></td></tr>
<tr class="separator:aa47365e82d9077f65082ade2212f6b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a4d63b899e0bfed36d1f7662a8880e"><td class="memTemplParams" colspan="2">template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:a43a4d63b899e0bfed36d1f7662a8880e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a43a4d63b899e0bfed36d1f7662a8880e">dynamic_unique_ptr_cast</a> (std::unique_ptr&lt; T &gt; &amp;&amp;base_ptr)</td></tr>
<tr class="memdesc:a43a4d63b899e0bfed36d1f7662a8880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a unique_ptr&lt;T&gt; to unique_ptr<u>. </u> <a href="namespaceepi.html#a43a4d63b899e0bfed36d1f7662a8880e">More...</a><br /></td></tr>
<tr class="separator:a43a4d63b899e0bfed36d1f7662a8880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af935aa9e27620794604cfea702b7be18"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:af935aa9e27620794604cfea702b7be18"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af935aa9e27620794604cfea702b7be18">end</a> (const M &amp;m)</td></tr>
<tr class="memdesc:af935aa9e27620794604cfea702b7be18"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a const end iterator for the matrix m.  <a href="namespaceepi.html#af935aa9e27620794604cfea702b7be18">More...</a><br /></td></tr>
<tr class="separator:af935aa9e27620794604cfea702b7be18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f5832acbbcd0a4623c594a42b46090"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:af7f5832acbbcd0a4623c594a42b46090"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceepi.html#a9deae6f690facc4fe4d3d3641c1f0458">conjunction_v</a>&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;, <a class="el" href="namespaceepi_1_1details.html#addd30df2f588966f391bf5a9f25e3418">details::IsElementReference</a>&lt; M &gt; &gt;, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt; M, false &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af7f5832acbbcd0a4623c594a42b46090">end</a> (M &amp;m)</td></tr>
<tr class="memdesc:af7f5832acbbcd0a4623c594a42b46090"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a non-const end iterator for the matrix m.  <a href="namespaceepi.html#af7f5832acbbcd0a4623c594a42b46090">More...</a><br /></td></tr>
<tr class="separator:af7f5832acbbcd0a4623c594a42b46090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5773aad4934841325a3bc52203919ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab5773aad4934841325a3bc52203919ce">ensemble_mean</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;ensemble_results)</td></tr>
<tr class="memdesc:ab5773aad4934841325a3bc52203919ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes mean of each compartment, node, and time point over all runs input must be uniform as returned by interpolated_ensemble_result: same number of nodes, same time points and elements.  <a href="namespaceepi.html#ab5773aad4934841325a3bc52203919ce">More...</a><br /></td></tr>
<tr class="separator:ab5773aad4934841325a3bc52203919ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63265d6480ad7cc9f18beedbd0c2bd99"><td class="memTemplParams" colspan="2">template&lt;class Model &gt; </td></tr>
<tr class="memitem:a63265d6480ad7cc9f18beedbd0c2bd99"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Model &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a63265d6480ad7cc9f18beedbd0c2bd99">ensemble_params_percentile</a> (const std::vector&lt; std::vector&lt; Model &gt;&gt; &amp;ensemble_params, double p)</td></tr>
<tr class="memdesc:a63265d6480ad7cc9f18beedbd0c2bd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the p percentile of the parameters for each node.  <a href="namespaceepi.html#a63265d6480ad7cc9f18beedbd0c2bd99">More...</a><br /></td></tr>
<tr class="separator:a63265d6480ad7cc9f18beedbd0c2bd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151df8ac841d0287fa4e9b69b35a56a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a151df8ac841d0287fa4e9b69b35a56a8">ensemble_percentile</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;ensemble_result, double p)</td></tr>
<tr class="memdesc:a151df8ac841d0287fa4e9b69b35a56a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the p percentile of the result for each compartment, node, and time point.  <a href="namespaceepi.html#a151df8ac841d0287fa4e9b69b35a56a8">More...</a><br /></td></tr>
<tr class="separator:a151df8ac841d0287fa4e9b69b35a56a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7330126f86af0488787e500c530d4eb"><td class="memTemplParams" colspan="2">template&lt;class Sim &gt; </td></tr>
<tr class="memitem:aa7330126f86af0488787e500c530d4eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa7330126f86af0488787e500c530d4eb">evolve_model</a> (double t, double dt, <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;node)</td></tr>
<tr class="memdesc:aa7330126f86af0488787e500c530d4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge functor for migration simulation.  <a href="namespaceepi.html#aa7330126f86af0488787e500c530d4eb">More...</a><br /></td></tr>
<tr class="separator:aa7330126f86af0488787e500c530d4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d264a78cf80d2626467ca1667ffd60"><td class="memTemplParams" colspan="2">template&lt;class Model &gt; </td></tr>
<tr class="memitem:af3d264a78cf80d2626467ca1667ffd60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af3d264a78cf80d2626467ca1667ffd60">extrapolate_rki_results</a> (std::vector&lt; Model &gt; &amp;model, const std::string &amp;data_dir, const std::string &amp;results_dir, std::vector&lt; int &gt; const &amp;region, <a class="el" href="structepi_1_1Date.html">Date</a> date, const std::vector&lt; double &gt; &amp;scaling_factor_inf, double scaling_factor_icu, int num_days)</td></tr>
<tr class="memdesc:af3d264a78cf80d2626467ca1667ffd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets populations data from RKI into a <a class="el" href="classepi_1_1SecirModel.html">SecirModel</a>  <a href="namespaceepi.html#af3d264a78cf80d2626467ca1667ffd60">More...</a><br /></td></tr>
<tr class="separator:af3d264a78cf80d2626467ca1667ffd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea56b39210ff5804ca2e9f70c4803859"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aea56b39210ff5804ca2e9f70c4803859">failure</a> (const <a class="el" href="classepi_1_1IOStatus.html">IOStatus</a> &amp;s)</td></tr>
<tr class="memdesc:aea56b39210ff5804ca2e9f70c4803859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object that is implicitly convertible to an error IOResult&lt;T&gt;.  <a href="namespaceepi.html#aea56b39210ff5804ca2e9f70c4803859">More...</a><br /></td></tr>
<tr class="separator:aea56b39210ff5804ca2e9f70c4803859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bd1217065c2bc450f95d7ed82c6e20"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a98bd1217065c2bc450f95d7ed82c6e20">failure</a> (std::error_code c, const std::string &amp;msg=&quot;&quot;)</td></tr>
<tr class="memdesc:a98bd1217065c2bc450f95d7ed82c6e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object that is implicitly convertible to an error IOResult&lt;T&gt;.  <a href="namespaceepi.html#a98bd1217065c2bc450f95d7ed82c6e20">More...</a><br /></td></tr>
<tr class="separator:a98bd1217065c2bc450f95d7ed82c6e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a4631ea790b11ade8145033400152b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab0a4631ea790b11ade8145033400152b">file_exists</a> (std::string const &amp;rel_path, std::string &amp;abs_path)</td></tr>
<tr class="separator:ab0a4631ea790b11ade8145033400152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7759228642eb55b650e9be3bc77588a4"><td class="memTemplParams" colspan="2">template&lt;class TS , class FP &gt; </td></tr>
<tr class="memitem:a7759228642eb55b650e9be3bc77588a4"><td class="memTemplItemLeft" align="right" valign="top">decltype(std::declval&lt; TS &gt;().rend())&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a7759228642eb55b650e9be3bc77588a4">find_value_reverse</a> (TS &amp;&amp;ts, FP t_search, FP abs_tol=0, FP rel_tol=0)</td></tr>
<tr class="memdesc:a7759228642eb55b650e9be3bc77588a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the value in the time series at time t_search starting from the end.  <a href="namespaceepi.html#a7759228642eb55b650e9be3bc77588a4">More...</a><br /></td></tr>
<tr class="separator:a7759228642eb55b650e9be3bc77588a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42a7f19595695226bfc43b114ce45a9"><td class="memTemplParams" colspan="2">template&lt;typename MultiIndex &gt; </td></tr>
<tr class="memitem:ad42a7f19595695226bfc43b114ce45a9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad42a7f19595695226bfc43b114ce45a9">flatten_index</a> (MultiIndex const &amp;indices, MultiIndex const &amp;dimensions)</td></tr>
<tr class="memdesc:ad42a7f19595695226bfc43b114ce45a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">flatten_index takes a set of indices into a mutlidemsional array and calculates the flat index  <a href="namespaceepi.html#ad42a7f19595695226bfc43b114ce45a9">More...</a><br /></td></tr>
<tr class="separator:ad42a7f19595695226bfc43b114ce45a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f731d1062d32349437a6a6a8f609576"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4f731d1062d32349437a6a6a8f609576"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a4f731d1062d32349437a6a6a8f609576">floating_point_equal</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:a4f731d1062d32349437a6a6a8f609576"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values for equality with tolerances.  <a href="namespaceepi.html#a4f731d1062d32349437a6a6a8f609576">More...</a><br /></td></tr>
<tr class="separator:a4f731d1062d32349437a6a6a8f609576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedd090715640a8adc75a509d28b68ba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aeedd090715640a8adc75a509d28b68ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aeedd090715640a8adc75a509d28b68ba">floating_point_greater</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:aeedd090715640a8adc75a509d28b68ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values with tolerances.  <a href="namespaceepi.html#aeedd090715640a8adc75a509d28b68ba">More...</a><br /></td></tr>
<tr class="separator:aeedd090715640a8adc75a509d28b68ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28f87b1b1b5c3170b6e5c91efd835bd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad28f87b1b1b5c3170b6e5c91efd835bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad28f87b1b1b5c3170b6e5c91efd835bd">floating_point_greater_equal</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:ad28f87b1b1b5c3170b6e5c91efd835bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values with tolerances.  <a href="namespaceepi.html#ad28f87b1b1b5c3170b6e5c91efd835bd">More...</a><br /></td></tr>
<tr class="separator:ad28f87b1b1b5c3170b6e5c91efd835bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5218181b2f8fed7b6cc322bbf0b49d12"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5218181b2f8fed7b6cc322bbf0b49d12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a5218181b2f8fed7b6cc322bbf0b49d12">floating_point_less</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:a5218181b2f8fed7b6cc322bbf0b49d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values with tolerances.  <a href="namespaceepi.html#a5218181b2f8fed7b6cc322bbf0b49d12">More...</a><br /></td></tr>
<tr class="separator:a5218181b2f8fed7b6cc322bbf0b49d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9644e0776f61a278b78d8fb7d1d0bc7e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9644e0776f61a278b78d8fb7d1d0bc7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a9644e0776f61a278b78d8fb7d1d0bc7e">floating_point_less_equal</a> (T v1, T v2, T abs_tol=0, T rel_tol=std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:a9644e0776f61a278b78d8fb7d1d0bc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare two floating point values with tolerances.  <a href="namespaceepi.html#a9644e0776f61a278b78d8fb7d1d0bc7e">More...</a><br /></td></tr>
<tr class="separator:a9644e0776f61a278b78d8fb7d1d0bc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337790a4a6a135a145d173fd7539ad98"><td class="memTemplParams" colspan="2">template&lt;class F , class... Tags&gt; </td></tr>
<tr class="memitem:a337790a4a6a135a145d173fd7539ad98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a337790a4a6a135a145d173fd7539ad98">foreach</a> (const <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; Tags... &gt; &amp;p, F f)</td></tr>
<tr class="memdesc:a337790a4a6a135a145d173fd7539ad98"><td class="mdescLeft">&#160;</td><td class="mdescRight">call f(p, t) for all parameters in a <a class="el" href="classepi_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> with p the value of the parameter t a default constructed parameter tag  <a href="namespaceepi.html#a337790a4a6a135a145d173fd7539ad98">More...</a><br /></td></tr>
<tr class="separator:a337790a4a6a135a145d173fd7539ad98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf60f98246e8bc423e8523e05f36617"><td class="memTemplParams" colspan="2">template&lt;class F , class... Tags&gt; </td></tr>
<tr class="memitem:acaf60f98246e8bc423e8523e05f36617"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#acaf60f98246e8bc423e8523e05f36617">foreach</a> (<a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; Tags... &gt; &amp;p, F f)</td></tr>
<tr class="separator:acaf60f98246e8bc423e8523e05f36617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a9d55aaa29669f5e5d465bc3d40e6a"><td class="memTemplParams" colspan="2">template&lt;class Params , class F &gt; </td></tr>
<tr class="memitem:a30a9d55aaa29669f5e5d465bc3d40e6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a30a9d55aaa29669f5e5d465bc3d40e6a">foreach_tag</a> (F f)</td></tr>
<tr class="memdesc:a30a9d55aaa29669f5e5d465bc3d40e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">call f(t) for all parameters in a <a class="el" href="classepi_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> with t a default constructed parameter tag  <a href="namespaceepi.html#a30a9d55aaa29669f5e5d465bc3d40e6a">More...</a><br /></td></tr>
<tr class="separator:a30a9d55aaa29669f5e5d465bc3d40e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbc2ed7c5465ea9c2cfb9fac3b13520"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7fbc2ed7c5465ea9c2cfb9fac3b13520"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::tuple_element&lt; I, std::tuple&lt; <a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags &gt;... &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a7fbc2ed7c5465ea9c2cfb9fac3b13520">get</a> (<a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags... &gt; &amp;i) noexcept</td></tr>
<tr class="separator:a7fbc2ed7c5465ea9c2cfb9fac3b13520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ea5b3eb337484365b27f41df6b7f69"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a27ea5b3eb337484365b27f41df6b7f69"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classepi_1_1Index.html">Index</a>&lt; <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a27ea5b3eb337484365b27f41df6b7f69">get</a> (<a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags... &gt; &amp;i) noexcept</td></tr>
<tr class="separator:a27ea5b3eb337484365b27f41df6b7f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4fbb799074a4cc04ea8a0babeacf15"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ada4fbb799074a4cc04ea8a0babeacf15"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::tuple_element&lt; I, std::tuple&lt; <a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags &gt;... &gt; &gt;::type const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ada4fbb799074a4cc04ea8a0babeacf15">get</a> (<a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags... &gt; const &amp;i) noexcept</td></tr>
<tr class="separator:ada4fbb799074a4cc04ea8a0babeacf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab311b8323aa23aea0da2bf70b01891b2"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab311b8323aa23aea0da2bf70b01891b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classepi_1_1Index.html">Index</a>&lt; <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a> &gt; const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab311b8323aa23aea0da2bf70b01891b2">get</a> (<a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags... &gt; const &amp;i) noexcept</td></tr>
<tr class="separator:ab311b8323aa23aea0da2bf70b01891b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279b902eaea75789d1cb3e6fb4fc88b3"><td class="memTemplParams" colspan="2">template&lt;class DampingExpr &gt; </td></tr>
<tr class="memitem:a279b902eaea75789d1cb3e6fb4fc88b3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Ref&lt; const typename DampingExpr::Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a279b902eaea75789d1cb3e6fb4fc88b3">get_active_damping</a> (const DampingExpr &amp;damping_expr, DampingLevel lvl, DampingType type, <a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a> t)</td></tr>
<tr class="memdesc:a279b902eaea75789d1cb3e6fb4fc88b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the damping that matches the given type and level and that is active at the specified time.  <a href="namespaceepi.html#a279b902eaea75789d1cb3e6fb4fc88b3">More...</a><br /></td></tr>
<tr class="separator:a279b902eaea75789d1cb3e6fb4fc88b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b95cd167f5b05ea85d763da3ae8002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a57b95cd167f5b05ea85d763da3ae8002">get_county_ids</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a57b95cd167f5b05ea85d763da3ae8002"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a vector with the ids of all german counties  <a href="namespaceepi.html#a57b95cd167f5b05ea85d763da3ae8002">More...</a><br /></td></tr>
<tr class="separator:a57b95cd167f5b05ea85d763da3ae8002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84705a311d53bb6f2f15c8e95955bb4c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a84705a311d53bb6f2f15c8e95955bb4c">get_current_dir_name</a> ()</td></tr>
<tr class="memdesc:a84705a311d53bb6f2f15c8e95955bb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current working directory name.  <a href="namespaceepi.html#a84705a311d53bb6f2f15c8e95955bb4c">More...</a><br /></td></tr>
<tr class="separator:a84705a311d53bb6f2f15c8e95955bb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fe15b03cd80011389629a1d6f5f414"><td class="memTemplParams" colspan="2">template&lt;class DampingExpr &gt; </td></tr>
<tr class="memitem:a07fe15b03cd80011389629a1d6f5f414"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a07fe15b03cd80011389629a1d6f5f414">get_damping_indices</a> (const DampingExpr &amp;damping_expr, DampingLevel lvl, DampingType type, <a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a> <a class="el" href="namespaceepi.html#a08e8b6a0525b440b6fcc4c958e4eb4ef">begin</a>, <a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a> <a class="el" href="namespaceepi.html#af7f5832acbbcd0a4623c594a42b46090">end</a>)</td></tr>
<tr class="memdesc:a07fe15b03cd80011389629a1d6f5f414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of indices of specified dampings.  <a href="namespaceepi.html#a07fe15b03cd80011389629a1d6f5f414">More...</a><br /></td></tr>
<tr class="separator:a07fe15b03cd80011389629a1d6f5f414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab806a15579c38196fd438b6de9064e86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab806a15579c38196fd438b6de9064e86">get_day_in_year</a> (<a class="el" href="structepi_1_1Date.html">Date</a> date)</td></tr>
<tr class="memdesc:ab806a15579c38196fd438b6de9064e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the day in year based on a given date.  <a href="namespaceepi.html#ab806a15579c38196fd438b6de9064e86">More...</a><br /></td></tr>
<tr class="separator:ab806a15579c38196fd438b6de9064e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedbe2736f98abcbddbb5030bc1c36f8"><td class="memTemplParams" colspan="2">template&lt;class Base  = Simulation&lt;SecirModel&gt;&gt; </td></tr>
<tr class="memitem:aaedbe2736f98abcbddbb5030bc1c36f8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aaedbe2736f98abcbddbb5030bc1c36f8">get_infections_relative</a> (const <a class="el" href="classepi_1_1SecirSimulation.html">SecirSimulation</a>&lt; Base &gt; &amp;model, double t, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;y)</td></tr>
<tr class="memdesc:aaedbe2736f98abcbddbb5030bc1c36f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get percentage of infections per total population.  <a href="namespaceepi.html#aaedbe2736f98abcbddbb5030bc1c36f8">More...</a><br /></td></tr>
<tr class="separator:aaedbe2736f98abcbddbb5030bc1c36f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5aaa132a35ad0befebd665dac41fa7b"><td class="memTemplParams" colspan="2">template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; get_infections_relative_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ac5aaa132a35ad0befebd665dac41fa7b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac5aaa132a35ad0befebd665dac41fa7b">get_infections_relative</a> (const <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;, double, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;)</td></tr>
<tr class="memdesc:ac5aaa132a35ad0befebd665dac41fa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the percantage of infected people of the total population in the node If dynamic NPIs are enabled, there needs to be an overload of get_infections_relative(model, y) for the Model type that can be found with argument-dependent lookup.  <a href="namespaceepi.html#ac5aaa132a35ad0befebd665dac41fa7b">More...</a><br /></td></tr>
<tr class="separator:ac5aaa132a35ad0befebd665dac41fa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c36a5ce9b2e07290a30ab659cc7ae8"><td class="memTemplParams" colspan="2">template&lt;class Base  = Simulation&lt;SecirModel&gt;&gt; </td></tr>
<tr class="memitem:a26c36a5ce9b2e07290a30ab659cc7ae8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a26c36a5ce9b2e07290a30ab659cc7ae8">get_migration_factors</a> (const <a class="el" href="classepi_1_1SecirSimulation.html">SecirSimulation</a>&lt; Base &gt; &amp;sim, double, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;y)</td></tr>
<tr class="memdesc:a26c36a5ce9b2e07290a30ab659cc7ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get migration factors.  <a href="namespaceepi.html#a26c36a5ce9b2e07290a30ab659cc7ae8">More...</a><br /></td></tr>
<tr class="separator:a26c36a5ce9b2e07290a30ab659cc7ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a57f9e3ae1cb3286ee8fa12382b21"><td class="memTemplParams" colspan="2">template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; get_migration_factors_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a175a57f9e3ae1cb3286ee8fa12382b21"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a175a57f9e3ae1cb3286ee8fa12382b21">get_migration_factors</a> (const <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;, double, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;y)</td></tr>
<tr class="memdesc:a175a57f9e3ae1cb3286ee8fa12382b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an additional migration factor.  <a href="namespaceepi.html#a175a57f9e3ae1cb3286ee8fa12382b21">More...</a><br /></td></tr>
<tr class="separator:a175a57f9e3ae1cb3286ee8fa12382b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bc0438a59f5c4b94f7c7b5897f478c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a86bc0438a59f5c4b94f7c7b5897f478c">get_offset_in_days</a> (<a class="el" href="structepi_1_1Date.html">Date</a> date1, <a class="el" href="structepi_1_1Date.html">Date</a> date2)</td></tr>
<tr class="memdesc:a86bc0438a59f5c4b94f7c7b5897f478c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the offset in days given two dates: first date minus second date.  <a href="namespaceepi.html#a86bc0438a59f5c4b94f7c7b5897f478c">More...</a><br /></td></tr>
<tr class="separator:a86bc0438a59f5c4b94f7c7b5897f478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8439865d7d71fb2382b3b2785aed2753"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a8439865d7d71fb2382b3b2785aed2753">hours</a> (int hours)</td></tr>
<tr class="memdesc:a8439865d7d71fb2382b3b2785aed2753"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a <a class="el" href="classepi_1_1TimeSpan.html" title="a duration of time.">TimeSpan</a> of a specified number of hours.  <a href="namespaceepi.html#a8439865d7d71fb2382b3b2785aed2753">More...</a><br /></td></tr>
<tr class="separator:a8439865d7d71fb2382b3b2785aed2753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa64417a4719c5d1b6d0d7092a91ffe5"><td class="memTemplParams" colspan="2">template&lt;class DampingExprGroup , class MakeMatrix &gt; </td></tr>
<tr class="memitem:aaa64417a4719c5d1b6d0d7092a91ffe5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aaa64417a4719c5d1b6d0d7092a91ffe5">implement_dynamic_npis</a> (DampingExprGroup &amp;damping_expr_group, const std::vector&lt; <a class="el" href="classepi_1_1DampingSampling.html">DampingSampling</a> &gt; &amp;npis, <a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a> <a class="el" href="namespaceepi.html#a08e8b6a0525b440b6fcc4c958e4eb4ef">begin</a>, <a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a> <a class="el" href="namespaceepi.html#af7f5832acbbcd0a4623c594a42b46090">end</a>, MakeMatrix &amp;&amp;make_matrix)</td></tr>
<tr class="memdesc:aaa64417a4719c5d1b6d0d7092a91ffe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement dynamic NPIs for a time span.  <a href="namespaceepi.html#aaa64417a4719c5d1b6d0d7092a91ffe5">More...</a><br /></td></tr>
<tr class="separator:aaa64417a4719c5d1b6d0d7092a91ffe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb9e6904c93b4dc7834448dd98e59a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0cb9e6904c93b4dc7834448dd98e59a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0cb9e6904c93b4dc7834448dd98e59a6">insert_sorted_replace</a> (std::vector&lt; T &gt; &amp;vec, T const &amp;item)</td></tr>
<tr class="separator:a0cb9e6904c93b4dc7834448dd98e59a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9392c02c0e21e76d64e16bce3b198dff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a9392c02c0e21e76d64e16bce3b198dff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a9392c02c0e21e76d64e16bce3b198dff">insert_sorted_replace</a> (std::vector&lt; T &gt; &amp;vec, T const &amp;item, Pred pred)</td></tr>
<tr class="memdesc:a9392c02c0e21e76d64e16bce3b198dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element in a sorted vector, replacing items that are equal precondition: elements in the vector are partially sorted and unique according the predicate postcondition: same as precondition, additionally contains exactly one element that is equal to item, order of other items is preserved  <a href="namespaceepi.html#a9392c02c0e21e76d64e16bce3b198dff">More...</a><br /></td></tr>
<tr class="separator:a9392c02c0e21e76d64e16bce3b198dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b02b1dc709b5f9253f71ec29d17e862"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2b02b1dc709b5f9253f71ec29d17e862"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceepi.html#aec4b1dbb8f2d81b0e5af433760fc156c">InterpolateResultT</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a2b02b1dc709b5f9253f71ec29d17e862">interpolate_ensemble_results</a> (const std::vector&lt; T &gt; &amp;ensemble_results)</td></tr>
<tr class="memdesc:a2b02b1dc709b5f9253f71ec29d17e862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates results of all runs with evenly spaced, integer time points.  <a href="namespaceepi.html#a2b02b1dc709b5f9253f71ec29d17e862">More...</a><br /></td></tr>
<tr class="separator:a2b02b1dc709b5f9253f71ec29d17e862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d23ba06a863a2a3fbed1a851774ddf"><td class="memTemplParams" colspan="2">template&lt;class Simulation &gt; </td></tr>
<tr class="memitem:ac1d23ba06a863a2a3fbed1a851774ddf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac1d23ba06a863a2a3fbed1a851774ddf">interpolate_simulation_result</a> (const <a class="el" href="classepi_1_1Graph.html">Graph</a>&lt; <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; <a class="el" href="classepi_1_1Simulation.html">Simulation</a> &gt;, <a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;graph_result)</td></tr>
<tr class="memdesc:ac1d23ba06a863a2a3fbed1a851774ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolate time series with evenly spaced, integer time points for each node.  <a href="namespaceepi.html#ac1d23ba06a863a2a3fbed1a851774ddf">More...</a><br /></td></tr>
<tr class="separator:ac1d23ba06a863a2a3fbed1a851774ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfb5f0f7703e75e9667ff4bedcf5e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a9dfb5f0f7703e75e9667ff4bedcf5e97">interpolate_simulation_result</a> (const <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &amp;simulation_result)</td></tr>
<tr class="memdesc:a9dfb5f0f7703e75e9667ff4bedcf5e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: extrapolate first and last point.  <a href="namespaceepi.html#a9dfb5f0f7703e75e9667ff4bedcf5e97">More...</a><br /></td></tr>
<tr class="separator:a9dfb5f0f7703e75e9667ff4bedcf5e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7efd28c38b8396b5e973ef50651f91"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aea7efd28c38b8396b5e973ef50651f91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aea7efd28c38b8396b5e973ef50651f91">log</a> (<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a> level, spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:aea7efd28c38b8396b5e973ef50651f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fd2a4b9b1aa2015f4e81d325579012"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae9fd2a4b9b1aa2015f4e81d325579012"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ae9fd2a4b9b1aa2015f4e81d325579012">log_debug</a> (spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:ae9fd2a4b9b1aa2015f4e81d325579012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af340c99e598304426b460ebb1b8337ea"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af340c99e598304426b460ebb1b8337ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af340c99e598304426b460ebb1b8337ea">log_error</a> (spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:af340c99e598304426b460ebb1b8337ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02ac4b2145bcd08b1106c26df127a2f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad02ac4b2145bcd08b1106c26df127a2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad02ac4b2145bcd08b1106c26df127a2f">log_info</a> (spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:ad02ac4b2145bcd08b1106c26df127a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d87d1c357272a7bd0879c96c3920ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad2d87d1c357272a7bd0879c96c3920ae">log_rng_seeds</a> (const <a class="el" href="classepi_1_1RandomNumberGenerator.html">RandomNumberGenerator</a> &amp;rng, <a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a> level)</td></tr>
<tr class="separator:ad2d87d1c357272a7bd0879c96c3920ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e96e0c7cf69c7e79851b152319e09e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a43e96e0c7cf69c7e79851b152319e09e">log_thread_local_rng_seeds</a> (<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a> level)</td></tr>
<tr class="separator:a43e96e0c7cf69c7e79851b152319e09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d95c3ae27c7d000e7ec3efe67efe3a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a60d95c3ae27c7d000e7ec3efe67efe3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a60d95c3ae27c7d000e7ec3efe67efe3a">log_warning</a> (spdlog::string_view_t fmt, const Args &amp;... args)</td></tr>
<tr class="separator:a60d95c3ae27c7d000e7ec3efe67efe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea3dfd561fb443543ac1543014f53fc"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:abea3dfd561fb443543ac1543014f53fc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#abea3dfd561fb443543ac1543014f53fc">major_size</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:abea3dfd561fb443543ac1543014f53fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows (columns) of a row (column) major matrix.  <a href="namespaceepi.html#abea3dfd561fb443543ac1543014f53fc">More...</a><br /></td></tr>
<tr class="separator:abea3dfd561fb443543ac1543014f53fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60af54eb89d33078a22ba5a5f1c89fa"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ab60af54eb89d33078a22ba5a5f1c89fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab60af54eb89d33078a22ba5a5f1c89fa">make_contact_damping_matrix</a> (V &amp;&amp;groups)</td></tr>
<tr class="memdesc:ab60af54eb89d33078a22ba5a5f1c89fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a contact damping matrix from dampings by group.  <a href="namespaceepi.html#ab60af54eb89d33078a22ba5a5f1c89fa">More...</a><br /></td></tr>
<tr class="separator:ab60af54eb89d33078a22ba5a5f1c89fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040956ca8ae80e87a860d2202981eb86"><td class="memItemLeft" align="right" valign="top">const std::error_code &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a040956ca8ae80e87a860d2202981eb86">make_error_code</a> (const <a class="el" href="classepi_1_1IOStatus.html">IOStatus</a> &amp;status)</td></tr>
<tr class="memdesc:a040956ca8ae80e87a860d2202981eb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> to std::error_code.  <a href="namespaceepi.html#a040956ca8ae80e87a860d2202981eb86">More...</a><br /></td></tr>
<tr class="separator:a040956ca8ae80e87a860d2202981eb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab983c9da111a8501867c8320c9c4c908"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab983c9da111a8501867c8320c9c4c908">make_error_code</a> (<a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ce">StatusCode</a> e)</td></tr>
<tr class="memdesc:ab983c9da111a8501867c8320c9c4c908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert StatusCode to std::error_code.  <a href="namespaceepi.html#ab983c9da111a8501867c8320c9c4c908">More...</a><br /></td></tr>
<tr class="separator:ab983c9da111a8501867c8320c9c4c908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f13a4d8ef4051c7bdedcfb2b4152c3"><td class="memTemplParams" colspan="2">template&lt;class Graph , class NodeF , class EdgeF &gt; </td></tr>
<tr class="memitem:a44f13a4d8ef4051c7bdedcfb2b4152c3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a44f13a4d8ef4051c7bdedcfb2b4152c3">make_graph_sim</a> (double t0, double dt, <a class="el" href="classepi_1_1Graph.html">Graph</a> &amp;&amp;g, NodeF &amp;&amp;node_func, EdgeF &amp;&amp;edge_func)</td></tr>
<tr class="separator:a44f13a4d8ef4051c7bdedcfb2b4152c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0425e3efce900644c00db5db5c6f33d4"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a0425e3efce900644c00db5db5c6f33d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0425e3efce900644c00db5db5c6f33d4">make_migration_damping_vector</a> (<a class="el" href="classepi_1_1ColumnVectorShape.html">ColumnVectorShape</a> shape, V &amp;&amp;groups)</td></tr>
<tr class="memdesc:a0425e3efce900644c00db5db5c6f33d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make migration coefficient damping vector from dampings by group.  <a href="namespaceepi.html#a0425e3efce900644c00db5db5c6f33d4">More...</a><br /></td></tr>
<tr class="separator:a0425e3efce900644c00db5db5c6f33d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d5e8ca704a28fff2d40c32a548e921"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96d5e8ca704a28fff2d40c32a548e921"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classepi_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a96d5e8ca704a28fff2d40c32a548e921">make_observer</a> (T *p)</td></tr>
<tr class="separator:a96d5e8ca704a28fff2d40c32a548e921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647bf8579337d11164eec7bcc3b2f3f8"><td class="memTemplParams" colspan="2">template&lt;class Iter1 , class Iter2 &gt; </td></tr>
<tr class="memitem:a647bf8579337d11164eec7bcc3b2f3f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a647bf8579337d11164eec7bcc3b2f3f8">make_range</a> (Iter1 &amp;&amp;iter1, Iter2 &amp;&amp;iter2)</td></tr>
<tr class="separator:a647bf8579337d11164eec7bcc3b2f3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7062f556f01dc09259d600017a3cd1"><td class="memTemplParams" colspan="2">template&lt;class IterPair &gt; </td></tr>
<tr class="memitem:a4c7062f556f01dc09259d600017a3cd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a4c7062f556f01dc09259d600017a3cd1">make_range</a> (IterPair &amp;&amp;p)</td></tr>
<tr class="memdesc:a4c7062f556f01dc09259d600017a3cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">factories for template argument deduction  <a href="namespaceepi.html#a4c7062f556f01dc09259d600017a3cd1">More...</a><br /></td></tr>
<tr class="separator:a4c7062f556f01dc09259d600017a3cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581ff5aecdf59ce593360a1b53457cb1"><td class="memTemplParams" colspan="2">template&lt;class Rng , class F &gt; </td></tr>
<tr class="memitem:a581ff5aecdf59ce593360a1b53457cb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a581ff5aecdf59ce593360a1b53457cb1">map</a> (const Rng &amp;v, F f)</td></tr>
<tr class="memdesc:a581ff5aecdf59ce593360a1b53457cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a random access range (i.e.  <a href="namespaceepi.html#a581ff5aecdf59ce593360a1b53457cb1">More...</a><br /></td></tr>
<tr class="separator:a581ff5aecdf59ce593360a1b53457cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad671e5cd3a4ab1b63f066b3b7d4e7e2f"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:ad671e5cd3a4ab1b63f066b3b7d4e7e2f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ad671e5cd3a4ab1b63f066b3b7d4e7e2f">max</a> (const Eigen::MatrixBase&lt; A &gt; &amp;a, B &amp;&amp;b)</td></tr>
<tr class="memdesc:ad671e5cd3a4ab1b63f066b3b7d4e7e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">coefficient wise maximum of two matrices.  <a href="namespaceepi.html#ad671e5cd3a4ab1b63f066b3b7d4e7e2f">More...</a><br /></td></tr>
<tr class="separator:ad671e5cd3a4ab1b63f066b3b7d4e7e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f5e455e9258212cdb0e51a1f97a586"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a75f5e455e9258212cdb0e51a1f97a586"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a75f5e455e9258212cdb0e51a1f97a586">minor_size</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a75f5e455e9258212cdb0e51a1f97a586"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns (rows) of a row (column) major matrix.  <a href="namespaceepi.html#a75f5e455e9258212cdb0e51a1f97a586">More...</a><br /></td></tr>
<tr class="separator:a75f5e455e9258212cdb0e51a1f97a586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7f2f3c9c94a6990a6bff230b1c7f30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a6e7f2f3c9c94a6990a6bff230b1c7f30">offset_date_by_days</a> (<a class="el" href="structepi_1_1Date.html">Date</a> date, int offset_days)</td></tr>
<tr class="memdesc:a6e7f2f3c9c94a6990a6bff230b1c7f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the new date corresponding to a given date and a offset in days.  <a href="namespaceepi.html#a6e7f2f3c9c94a6990a6bff230b1c7f30">More...</a><br /></td></tr>
<tr class="separator:a6e7f2f3c9c94a6990a6bff230b1c7f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e85ce3d223aad59b2dc369e3eb0d28c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e85ce3d223aad59b2dc369e3eb0d28c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a6e85ce3d223aad59b2dc369e3eb0d28c">operator!=</a> (const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e1, const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e2)</td></tr>
<tr class="separator:a6e85ce3d223aad59b2dc369e3eb0d28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade052ae39516a7c1232ad35ffcc281d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ade052ae39516a7c1232ad35ffcc281d8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ade052ae39516a7c1232ad35ffcc281d8">operator!=</a> (const <a class="el" href="structepi_1_1Node.html">Node</a>&lt; T &gt; &amp;n1, const <a class="el" href="structepi_1_1Node.html">Node</a>&lt; T &gt; &amp;n2)</td></tr>
<tr class="separator:ade052ae39516a7c1232ad35ffcc281d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47b1f4d8dcf4e73189d1d7bc52266ec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae47b1f4d8dcf4e73189d1d7bc52266ec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a>&lt; T &gt;::value, std::ostream &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ae47b1f4d8dcf4e73189d1d7bc52266ec">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e)</td></tr>
<tr class="memdesc:ae47b1f4d8dcf4e73189d1d7bc52266ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">out stream operator for edges if edge property type has stream operator defined  <a href="namespaceepi.html#ae47b1f4d8dcf4e73189d1d7bc52266ec">More...</a><br /></td></tr>
<tr class="separator:ae47b1f4d8dcf4e73189d1d7bc52266ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa66fe98b87799627f7a73c780a11331"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afa66fe98b87799627f7a73c780a11331"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a>&lt; T &gt;::value, std::ostream &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#afa66fe98b87799627f7a73c780a11331">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e)</td></tr>
<tr class="memdesc:afa66fe98b87799627f7a73c780a11331"><td class="mdescLeft">&#160;</td><td class="mdescRight">out stream operator for edges if edge property type does not have stream operator defined  <a href="namespaceepi.html#afa66fe98b87799627f7a73c780a11331">More...</a><br /></td></tr>
<tr class="separator:afa66fe98b87799627f7a73c780a11331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f154756e9e9cc7cf261b6ee9a725e9e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8f154756e9e9cc7cf261b6ee9a725e9e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a8f154756e9e9cc7cf261b6ee9a725e9e">operator==</a> (const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e1, const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;e2)</td></tr>
<tr class="memdesc:a8f154756e9e9cc7cf261b6ee9a725e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator if edge property type is equality comparable  <a href="namespaceepi.html#a8f154756e9e9cc7cf261b6ee9a725e9e">More...</a><br /></td></tr>
<tr class="separator:a8f154756e9e9cc7cf261b6ee9a725e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61d5abc1807be68b6531c48dbed9516"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab61d5abc1807be68b6531c48dbed9516"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab61d5abc1807be68b6531c48dbed9516">operator==</a> (const <a class="el" href="structepi_1_1Node.html">Node</a>&lt; T &gt; &amp;n1, const <a class="el" href="structepi_1_1Node.html">Node</a>&lt; T &gt; &amp;n2)</td></tr>
<tr class="memdesc:ab61d5abc1807be68b6531c48dbed9516"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator if node property type is equality comparable  <a href="namespaceepi.html#ab61d5abc1807be68b6531c48dbed9516">More...</a><br /></td></tr>
<tr class="separator:ab61d5abc1807be68b6531c48dbed9516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5627edce6ec776893a7a80bfe92c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a4f5627edce6ec776893a7a80bfe92c51">parse_date</a> (const std::string &amp;date_str)</td></tr>
<tr class="memdesc:a4f5627edce6ec776893a7a80bfe92c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses a date from a string.  <a href="namespaceepi.html#a4f5627edce6ec776893a7a80bfe92c51">More...</a><br /></td></tr>
<tr class="separator:a4f5627edce6ec776893a7a80bfe92c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4595ae862d8bd1d17a7acd5bdf9eed75"><td class="memTemplParams" colspan="2">template&lt;class String , class... Strings&gt; </td></tr>
<tr class="memitem:a4595ae862d8bd1d17a7acd5bdf9eed75"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a4595ae862d8bd1d17a7acd5bdf9eed75">path_join</a> (String &amp;&amp;base, Strings &amp;&amp;... app)</td></tr>
<tr class="memdesc:a4595ae862d8bd1d17a7acd5bdf9eed75"><td class="mdescLeft">&#160;</td><td class="mdescRight">join one ore more strings with path separators.  <a href="namespaceepi.html#a4595ae862d8bd1d17a7acd5bdf9eed75">More...</a><br /></td></tr>
<tr class="separator:a4595ae862d8bd1d17a7acd5bdf9eed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f87f69b1ceb20f1a2e71c399e3abe13"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a6f87f69b1ceb20f1a2e71c399e3abe13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a6f87f69b1ceb20f1a2e71c399e3abe13">print_graph</a> (std::ostream &amp;os, const <a class="el" href="classepi_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="separator:a6f87f69b1ceb20f1a2e71c399e3abe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201d7af8010e9eab0c7d951a81c8aeb7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a201d7af8010e9eab0c7d951a81c8aeb7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a>&lt; T &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a201d7af8010e9eab0c7d951a81c8aeb7">print_graph_object</a> (std::ostream &amp;os, size_t idx, const T &amp;)</td></tr>
<tr class="separator:a201d7af8010e9eab0c7d951a81c8aeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af736f166eb9e6ca47a130a635562fb0b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af736f166eb9e6ca47a130a635562fb0b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a>&lt; T &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af736f166eb9e6ca47a130a635562fb0b">print_graph_object</a> (std::ostream &amp;os, size_t idx, const T &amp;o)</td></tr>
<tr class="separator:af736f166eb9e6ca47a130a635562fb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbce423b42545473a89380554ba0b45c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#acbce423b42545473a89380554ba0b45c">print_seir_params</a> (const <a class="el" href="classepi_1_1SeirModel.html">SeirModel</a> &amp;model)</td></tr>
<tr class="memdesc:acbce423b42545473a89380554ba0b45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints given parameters  <a href="namespaceepi.html#acbce423b42545473a89380554ba0b45c">More...</a><br /></td></tr>
<tr class="separator:acbce423b42545473a89380554ba0b45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae264f41ee1dab690ef20b8cf9afb0957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ae264f41ee1dab690ef20b8cf9afb0957">PrintTo</a> (const <a class="el" href="classepi_1_1IOStatus.html">IOStatus</a> &amp;status, std::ostream *os)</td></tr>
<tr class="memdesc:ae264f41ee1dab690ef20b8cf9afb0957"><td class="mdescLeft">&#160;</td><td class="mdescRight">gtest printer for <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a>.  <a href="namespaceepi.html#ae264f41ee1dab690ef20b8cf9afb0957">More...</a><br /></td></tr>
<tr class="separator:ae264f41ee1dab690ef20b8cf9afb0957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e0a062523d918b5aa5af93e7c6692b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a07e0a062523d918b5aa5af93e7c6692b">PrintTo</a> (const <a class="el" href="classepi_1_1UncertainValue.html">UncertainValue</a> &amp;uv, std::ostream *os)</td></tr>
<tr class="separator:a07e0a062523d918b5aa5af93e7c6692b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12182cdd3c2108a61069855e9bc9f976"><td class="memTemplParams" colspan="2">template&lt;class T , size_t NumTransitions&gt; </td></tr>
<tr class="memitem:a12182cdd3c2108a61069855e9bc9f976"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a12182cdd3c2108a61069855e9bc9f976">random_transition</a> (T current_state, <a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a> dt, const std::pair&lt; T, double &gt;(&amp;transitions)[NumTransitions])</td></tr>
<tr class="memdesc:a12182cdd3c2108a61069855e9bc9f976"><td class="mdescLeft">&#160;</td><td class="mdescRight">select a random transition from a list of possible transitions from the current state to others.  <a href="namespaceepi.html#a12182cdd3c2108a61069855e9bc9f976">More...</a><br /></td></tr>
<tr class="separator:a12182cdd3c2108a61069855e9bc9f976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f469d232b6a3b17f9748465a62acf"><td class="memTemplParams" colspan="2">template&lt;class Model &gt; </td></tr>
<tr class="memitem:ac70f469d232b6a3b17f9748465a62acf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; <a class="el" href="classepi_1_1Graph.html">Graph</a>&lt; Model, <a class="el" href="classepi_1_1MigrationParameters.html">MigrationParameters</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac70f469d232b6a3b17f9748465a62acf">read_graph</a> (const std::string &amp;directory, int ioflags=<a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a>)</td></tr>
<tr class="memdesc:ac70f469d232b6a3b17f9748465a62acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads graph json files and returns a simulation graph.  <a href="namespaceepi.html#ac70f469d232b6a3b17f9748465a62acf">More...</a><br /></td></tr>
<tr class="separator:ac70f469d232b6a3b17f9748465a62acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8939e488603b6fe019d5ba85e0afad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; Json::Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a9f8939e488603b6fe019d5ba85e0afad">read_json</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a9f8939e488603b6fe019d5ba85e0afad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a json value from a file.  <a href="namespaceepi.html#a9f8939e488603b6fe019d5ba85e0afad">More...</a><br /></td></tr>
<tr class="separator:a9f8939e488603b6fe019d5ba85e0afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0987b8a2671181957dbbcc612cba11"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8d0987b8a2671181957dbbcc612cba11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a8d0987b8a2671181957dbbcc612cba11">read_json</a> (const std::string &amp;path, <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; T &gt; tag, int flags=<a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a>)</td></tr>
<tr class="memdesc:a8d0987b8a2671181957dbbcc612cba11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a json value from a file and deserialize it into an object.  <a href="namespaceepi.html#a8d0987b8a2671181957dbbcc612cba11">More...</a><br /></td></tr>
<tr class="separator:a8d0987b8a2671181957dbbcc612cba11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6dd630c672a729aad58836976efb87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aaf6dd630c672a729aad58836976efb87">read_mobility_formatted</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:aaf6dd630c672a729aad58836976efb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads formatted migration or contact data which is given in columns from_str to_str from_rs to_rs count_abs and separated by tabs.  <a href="namespaceepi.html#aaf6dd630c672a729aad58836976efb87">More...</a><br /></td></tr>
<tr class="separator:aaf6dd630c672a729aad58836976efb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d4ad2f5843dc2359c155c733b9295b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a53d4ad2f5843dc2359c155c733b9295b">read_mobility_plain</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a53d4ad2f5843dc2359c155c733b9295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads txt migration data or contact which is given by values only and separated by spaces.  <a href="namespaceepi.html#a53d4ad2f5843dc2359c155c733b9295b">More...</a><br /></td></tr>
<tr class="separator:a53d4ad2f5843dc2359c155c733b9295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bb05811835f12b6509f65fefb08624"><td class="memTemplParams" colspan="2">template&lt;class Model &gt; </td></tr>
<tr class="memitem:a95bb05811835f12b6509f65fefb08624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a95bb05811835f12b6509f65fefb08624">read_population_data_county</a> (std::vector&lt; Model &gt; &amp;model, <a class="el" href="structepi_1_1Date.html">Date</a> date, const std::vector&lt; int &gt; &amp;county, const std::vector&lt; double &gt; &amp;scaling_factor_inf, double scaling_factor_icu, const std::string &amp;dir)</td></tr>
<tr class="memdesc:a95bb05811835f12b6509f65fefb08624"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads population data from population files for the specefied county  <a href="namespaceepi.html#a95bb05811835f12b6509f65fefb08624">More...</a><br /></td></tr>
<tr class="separator:a95bb05811835f12b6509f65fefb08624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a2a738cb0ff1f34dd754502a45665a"><td class="memTemplParams" colspan="2">template&lt;class Model &gt; </td></tr>
<tr class="memitem:af8a2a738cb0ff1f34dd754502a45665a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#af8a2a738cb0ff1f34dd754502a45665a">read_population_data_germany</a> (std::vector&lt; Model &gt; &amp;model, <a class="el" href="structepi_1_1Date.html">Date</a> date, const std::vector&lt; double &gt; &amp;scaling_factor_inf, double scaling_factor_icu, const std::string &amp;dir)</td></tr>
<tr class="memdesc:af8a2a738cb0ff1f34dd754502a45665a"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads population data from population files for the whole country  <a href="namespaceepi.html#af8a2a738cb0ff1f34dd754502a45665a">More...</a><br /></td></tr>
<tr class="separator:af8a2a738cb0ff1f34dd754502a45665a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834e31d5aabbe9d0d0d39e429a3b661d"><td class="memTemplParams" colspan="2">template&lt;class Model &gt; </td></tr>
<tr class="memitem:a834e31d5aabbe9d0d0d39e429a3b661d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a834e31d5aabbe9d0d0d39e429a3b661d">read_population_data_state</a> (std::vector&lt; Model &gt; &amp;model, <a class="el" href="structepi_1_1Date.html">Date</a> date, std::vector&lt; int &gt; &amp;state, const std::vector&lt; double &gt; &amp;scaling_factor_inf, double scaling_factor_icu, const std::string &amp;dir)</td></tr>
<tr class="memdesc:a834e31d5aabbe9d0d0d39e429a3b661d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads population data from population files for the specefied state  <a href="namespaceepi.html#a834e31d5aabbe9d0d0d39e429a3b661d">More...</a><br /></td></tr>
<tr class="separator:a834e31d5aabbe9d0d0d39e429a3b661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e4c461ef6658ee53825f5490981c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; std::vector&lt; <a class="el" href="classepi_1_1SecirSimulationResult.html">SecirSimulationResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aca4e4c461ef6658ee53825f5490981c2">read_result</a> (const std::string &amp;filename, int nb_groups)</td></tr>
<tr class="memdesc:aca4e4c461ef6658ee53825f5490981c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">read secir simulation result from h5 file  <a href="namespaceepi.html#aca4e4c461ef6658ee53825f5490981c2">More...</a><br /></td></tr>
<tr class="separator:aca4e4c461ef6658ee53825f5490981c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b36aafc23a8ab1b41f63a8f25b4e96"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ac2b36aafc23a8ab1b41f63a8f25b4e96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac2b36aafc23a8ab1b41f63a8f25b4e96">reshape</a> (M &amp;&amp;m, Eigen::Index rows, Eigen::Index cols)</td></tr>
<tr class="memdesc:ac2b36aafc23a8ab1b41f63a8f25b4e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">reshape the matrix.  <a href="namespaceepi.html#ac2b36aafc23a8ab1b41f63a8f25b4e96">More...</a><br /></td></tr>
<tr class="separator:ac2b36aafc23a8ab1b41f63a8f25b4e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a8a4cdffb9aaeafb0085c369530d3c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a61a8a4cdffb9aaeafb0085c369530d3c">result_distance_2norm</a> (const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">epi::TimeSeries</a>&lt; double &gt;&gt; &amp;result1, const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">epi::TimeSeries</a>&lt; double &gt;&gt; &amp;result2)</td></tr>
<tr class="memdesc:a61a8a4cdffb9aaeafb0085c369530d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two SECIR simulation results.  <a href="namespaceepi.html#a61a8a4cdffb9aaeafb0085c369530d3c">More...</a><br /></td></tr>
<tr class="separator:a61a8a4cdffb9aaeafb0085c369530d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7babc0f40c19f04b6847fd1c258fe86b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a7babc0f40c19f04b6847fd1c258fe86b">result_distance_2norm</a> (const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">epi::TimeSeries</a>&lt; double &gt;&gt; &amp;result1, const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">epi::TimeSeries</a>&lt; double &gt;&gt; &amp;result2, <a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092">InfectionState</a> compartment)</td></tr>
<tr class="memdesc:a7babc0f40c19f04b6847fd1c258fe86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two SECIR simulation results in one compartment.  <a href="namespaceepi.html#a7babc0f40c19f04b6847fd1c258fe86b">More...</a><br /></td></tr>
<tr class="separator:a7babc0f40c19f04b6847fd1c258fe86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb73a1a2ab77102ffcff487eda30e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a5bb73a1a2ab77102ffcff487eda30e21">save_result</a> (const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt; &amp;result, const std::vector&lt; int &gt; &amp;ids, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a5bb73a1a2ab77102ffcff487eda30e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">save secir simulation result to h5 file  <a href="namespaceepi.html#a5bb73a1a2ab77102ffcff487eda30e21">More...</a><br /></td></tr>
<tr class="separator:a5bb73a1a2ab77102ffcff487eda30e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a378052ad704e7ac76df0f0420d9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#afa8a378052ad704e7ac76df0f0420d9b">secir_get_derivatives</a> (<a class="el" href="classepi_1_1SecirParams.html">SecirParams</a> const &amp;params, Eigen::Ref&lt; const Eigen::VectorXd &gt; pop, Eigen::Ref&lt; const Eigen::VectorXd &gt; y, double t, Eigen::Ref&lt; Eigen::VectorXd &gt; dydt)</td></tr>
<tr class="separator:afa8a378052ad704e7ac76df0f0420d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eb3f9715193049cfe02fa1ae923024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a67eb3f9715193049cfe02fa1ae923024">seconds</a> (int seconds)</td></tr>
<tr class="memdesc:a67eb3f9715193049cfe02fa1ae923024"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a <a class="el" href="classepi_1_1TimeSpan.html" title="a duration of time.">TimeSpan</a> of a specified number of seconds.  <a href="namespaceepi.html#a67eb3f9715193049cfe02fa1ae923024">More...</a><br /></td></tr>
<tr class="separator:a67eb3f9715193049cfe02fa1ae923024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7695ed10dce7f77ba45a6a208aa801c"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T &gt; </td></tr>
<tr class="memitem:ab7695ed10dce7f77ba45a6a208aa801c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab7695ed10dce7f77ba45a6a208aa801c">serialize</a> (IOContext &amp;io, const T &amp;t)</td></tr>
<tr class="memdesc:ab7695ed10dce7f77ba45a6a208aa801c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save data that describes an object in a format determined by the given context.  <a href="namespaceepi.html#ab7695ed10dce7f77ba45a6a208aa801c">More...</a><br /></td></tr>
<tr class="separator:ab7695ed10dce7f77ba45a6a208aa801c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab963398e0444e5a1fc0f8d473fbf046d"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class Container , std::enable_if_t&lt;(is_container&lt; Container &gt;::value &amp;&amp;!is_expression_valid&lt; serialize_t, IOContext, Container &gt;::value), void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ab963398e0444e5a1fc0f8d473fbf046d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab963398e0444e5a1fc0f8d473fbf046d">serialize_internal</a> (IOContext &amp;io, const Container &amp;container)</td></tr>
<tr class="memdesc:ab963398e0444e5a1fc0f8d473fbf046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an STL compatible container.  <a href="namespaceepi.html#ab963398e0444e5a1fc0f8d473fbf046d">More...</a><br /></td></tr>
<tr class="separator:ab963398e0444e5a1fc0f8d473fbf046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f38e8c2daba6e250ec1399f37deb68e"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class M &gt; </td></tr>
<tr class="memitem:a9f38e8c2daba6e250ec1399f37deb68e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a9f38e8c2daba6e250ec1399f37deb68e">serialize_internal</a> (IOContext &amp;io, const Eigen::EigenBase&lt; M &gt; &amp;mat)</td></tr>
<tr class="memdesc:a9f38e8c2daba6e250ec1399f37deb68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an Eigen matrix expression.  <a href="namespaceepi.html#a9f38e8c2daba6e250ec1399f37deb68e">More...</a><br /></td></tr>
<tr class="separator:a9f38e8c2daba6e250ec1399f37deb68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab9b29e11eb8c5c74c20ac9e665f35c"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class T , std::enable_if_t&lt; is_expression_valid&lt; serialize_t, IOContext, T &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:abab9b29e11eb8c5c74c20ac9e665f35c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#abab9b29e11eb8c5c74c20ac9e665f35c">serialize_internal</a> (IOContext &amp;io, const T &amp;t)</td></tr>
<tr class="memdesc:abab9b29e11eb8c5c74c20ac9e665f35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an object that has a serialize(io) member function.  <a href="namespaceepi.html#abab9b29e11eb8c5c74c20ac9e665f35c">More...</a><br /></td></tr>
<tr class="separator:abab9b29e11eb8c5c74c20ac9e665f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76604f8ba20f3c1f7f5f057a57b4e526"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class Tup , class  = std::enable_if_t&lt;is_expression_valid&lt;details::tuple_size_value_t, Tup&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a76604f8ba20f3c1f7f5f057a57b4e526"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a76604f8ba20f3c1f7f5f057a57b4e526">serialize_internal</a> (IOContext &amp;io, const Tup &amp;tup)</td></tr>
<tr class="memdesc:a76604f8ba20f3c1f7f5f057a57b4e526"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize a tuple-like object, e.g.  <a href="namespaceepi.html#a76604f8ba20f3c1f7f5f057a57b4e526">More...</a><br /></td></tr>
<tr class="separator:a76604f8ba20f3c1f7f5f057a57b4e526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa07e252e4e11d512ffc40b255a1cfe"><td class="memTemplParams" colspan="2">template&lt;class IOContext , class E , std::enable_if_t&lt; std::is_enum&lt; E &gt;::value, void * &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:aefa07e252e4e11d512ffc40b255a1cfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aefa07e252e4e11d512ffc40b255a1cfe">serialize_internal</a> (IOContext &amp;io, E e)</td></tr>
<tr class="memdesc:aefa07e252e4e11d512ffc40b255a1cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize an enum value as its underlying type.  <a href="namespaceepi.html#aefa07e252e4e11d512ffc40b255a1cfe">More...</a><br /></td></tr>
<tr class="separator:aefa07e252e4e11d512ffc40b255a1cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d53cc671d69af5461a92c2b05dd0526"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0d53cc671d69af5461a92c2b05dd0526"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; Json::Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0d53cc671d69af5461a92c2b05dd0526">serialize_json</a> (const T &amp;t, int flags=<a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a>)</td></tr>
<tr class="memdesc:a0d53cc671d69af5461a92c2b05dd0526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object into json.  <a href="namespaceepi.html#a0d53cc671d69af5461a92c2b05dd0526">More...</a><br /></td></tr>
<tr class="separator:a0d53cc671d69af5461a92c2b05dd0526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c664f7bae0d089839cd34c9299f5c1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a9c664f7bae0d089839cd34c9299f5c1e">set_home_office</a> (<a class="el" href="classepi_1_1TimePoint.html">TimePoint</a> t_begin, double p, <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;params)</td></tr>
<tr class="memdesc:a9c664f7bae0d089839cd34c9299f5c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LockdownRules implements non phamarceutical interventions via dampings.  <a href="namespaceepi.html#a9c664f7bae0d089839cd34c9299f5c1e">More...</a><br /></td></tr>
<tr class="separator:a9c664f7bae0d089839cd34c9299f5c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07a4860425456127bbc2061666ab52d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ae07a4860425456127bbc2061666ab52d">set_log_level</a> (<a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a> level)</td></tr>
<tr class="memdesc:ae07a4860425456127bbc2061666ab52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the verbosity of the logger.  <a href="namespaceepi.html#ae07a4860425456127bbc2061666ab52d">More...</a><br /></td></tr>
<tr class="separator:ae07a4860425456127bbc2061666ab52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002f18b08370fd888f6d2064a4fd24a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a002f18b08370fd888f6d2064a4fd24a6">set_params_distributions_normal</a> (<a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;model, double t0, double tmax, double dev_rel)</td></tr>
<tr class="separator:a002f18b08370fd888f6d2064a4fd24a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd09e2f4ab61892c97cc8344764ceae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a6bd09e2f4ab61892c97cc8344764ceae">set_school_closure</a> (<a class="el" href="classepi_1_1TimePoint.html">TimePoint</a> t_begin, double p, <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;params)</td></tr>
<tr class="memdesc:a6bd09e2f4ab61892c97cc8344764ceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">If schools are closed, students stay at home instead of going to school.  <a href="namespaceepi.html#a6bd09e2f4ab61892c97cc8344764ceae">More...</a><br /></td></tr>
<tr class="separator:a6bd09e2f4ab61892c97cc8344764ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420b40f813bf76d271632438acb1f6a2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a420b40f813bf76d271632438acb1f6a2">simulate</a> (double t0, double tmax, double dt, const <a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;model, std::shared_ptr&lt; <a class="el" href="classepi_1_1IntegratorCore.html">IntegratorCore</a> &gt; integrator=nullptr)</td></tr>
<tr class="memdesc:a420b40f813bf76d271632438acb1f6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization of simulate for secir models using <a class="el" href="classepi_1_1SecirSimulation.html" title="specialization of compartment model simulation for secir models.">SecirSimulation</a>.  <a href="namespaceepi.html#a420b40f813bf76d271632438acb1f6a2">More...</a><br /></td></tr>
<tr class="separator:a420b40f813bf76d271632438acb1f6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3f2fcd2c303060c062fce863683646"><td class="memTemplParams" colspan="2">template&lt;class Model , class Sim  = Simulation&lt;Model&gt;&gt; </td></tr>
<tr class="memitem:a1d3f2fcd2c303060c062fce863683646"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; <a class="el" href="ScalarType_8h.html#acd4f1d492d83a74716a42615e127d641">ScalarType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a1d3f2fcd2c303060c062fce863683646">simulate</a> (double t0, double tmax, double dt, Model const &amp;model, std::shared_ptr&lt; <a class="el" href="classepi_1_1IntegratorCore.html">IntegratorCore</a> &gt; integrator=nullptr)</td></tr>
<tr class="memdesc:a1d3f2fcd2c303060c062fce863683646"><td class="mdescLeft">&#160;</td><td class="mdescRight">simulate simulates a compartmental model  <a href="namespaceepi.html#a1d3f2fcd2c303060c062fce863683646">More...</a><br /></td></tr>
<tr class="separator:a1d3f2fcd2c303060c062fce863683646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac668a516b3b81430fd9db1655be8ca3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac668a516b3b81430fd9db1655be8ca3c">simulate</a> (double t0, double tmax, double dt, <a class="el" href="classepi_1_1SecirParams.html">SecirParams</a> const &amp;params)</td></tr>
<tr class="separator:ac668a516b3b81430fd9db1655be8ca3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a009607559caffa453a30d1f34b92b"><td class="memTemplParams" colspan="2">template&lt;class M , std::enable_if_t&lt; is_dynamic_matrix&lt; M &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a04a009607559caffa453a30d1f34b92b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a04a009607559caffa453a30d1f34b92b">slice</a> (M &amp;&amp;m, <a class="el" href="structepi_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt; rows, <a class="el" href="structepi_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt; cols)</td></tr>
<tr class="memdesc:a04a009607559caffa453a30d1f34b92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">take a regular slice of a matrix.  <a href="namespaceepi.html#a04a009607559caffa453a30d1f34b92b">More...</a><br /></td></tr>
<tr class="separator:a04a009607559caffa453a30d1f34b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958f73d77f1bccbe6ba775f02b2f94ff"><td class="memTemplParams" colspan="2">template&lt;class V , std::enable_if_t&lt; is_dynamic_vector&lt; V &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a958f73d77f1bccbe6ba775f02b2f94ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a958f73d77f1bccbe6ba775f02b2f94ff">slice</a> (V &amp;&amp;v, <a class="el" href="structepi_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt; elems)</td></tr>
<tr class="memdesc:a958f73d77f1bccbe6ba775f02b2f94ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">take a regular slice of a row or column vector.  <a href="namespaceepi.html#a958f73d77f1bccbe6ba775f02b2f94ff">More...</a><br /></td></tr>
<tr class="separator:a958f73d77f1bccbe6ba775f02b2f94ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d384302b65a9ac67422556a8b71824"><td class="memTemplParams" colspan="2">template&lt;class LeftExpr , class RightExpr &gt; </td></tr>
<tr class="memitem:a27d384302b65a9ac67422556a8b71824"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a27d384302b65a9ac67422556a8b71824">smoother_cosine</a> (double x, double xleft, double xright, const Eigen::MatrixBase&lt; LeftExpr &gt; &amp;yleft_expr, const Eigen::MatrixBase&lt; RightExpr &gt; &amp;yright_expr)</td></tr>
<tr class="memdesc:a27d384302b65a9ac67422556a8b71824"><td class="mdescLeft">&#160;</td><td class="mdescRight">smoother_cosine as a matrix valued function.  <a href="namespaceepi.html#a27d384302b65a9ac67422556a8b71824">More...</a><br /></td></tr>
<tr class="separator:a27d384302b65a9ac67422556a8b71824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd4a5a005de9c26fe1a3e350db3b939"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#abcd4a5a005de9c26fe1a3e350db3b939">smoother_cosine</a> (double x, double xleft, double xright, double yleft, double yright)</td></tr>
<tr class="memdesc:abcd4a5a005de9c26fe1a3e350db3b939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smoothed evaluation of a discrete jump of function values <br  />
 yleft and yright on xleft and xright, respectively, by using a cosine function.  <a href="namespaceepi.html#abcd4a5a005de9c26fe1a3e350db3b939">More...</a><br /></td></tr>
<tr class="separator:abcd4a5a005de9c26fe1a3e350db3b939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a727e393588b9f803e41b5e994baa2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa3a727e393588b9f803e41b5e994baa2">split</a> (const std::string &amp;s, char delimiter)</td></tr>
<tr class="memdesc:aa3a727e393588b9f803e41b5e994baa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits string into a Vector of strings according to delimiter.  <a href="namespaceepi.html#aa3a727e393588b9f803e41b5e994baa2">More...</a><br /></td></tr>
<tr class="separator:aa3a727e393588b9f803e41b5e994baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ebb94e07f7faaadcb49c06e7cb5f68"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classepi_1_1detail_1_1StatusCodeCategory.html">detail::StatusCodeCategory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ae1ebb94e07f7faaadcb49c06e7cb5f68">status_code_category</a> ()</td></tr>
<tr class="memdesc:ae1ebb94e07f7faaadcb49c06e7cb5f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">singleton StatusCodeCategory instance.  <a href="namespaceepi.html#ae1ebb94e07f7faaadcb49c06e7cb5f68">More...</a><br /></td></tr>
<tr class="separator:ae1ebb94e07f7faaadcb49c06e7cb5f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9e70f5748c7a821d499813f11272b6"><td class="memItemLeft" align="right" valign="top">herr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#afb9e70f5748c7a821d499813f11272b6">store_group_name</a> (hid_t loc_id, const char *name, const H5L_info_t *linfo, void *opdata)</td></tr>
<tr class="separator:afb9e70f5748c7a821d499813f11272b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f628fcc67b59148c234bc6dd75d0e94"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a4f628fcc67b59148c234bc6dd75d0e94">success</a> ()</td></tr>
<tr class="memdesc:a4f628fcc67b59148c234bc6dd75d0e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object that is implicitly convertible to a succesful IOResult&lt;void&gt;.  <a href="namespaceepi.html#a4f628fcc67b59148c234bc6dd75d0e94">More...</a><br /></td></tr>
<tr class="separator:a4f628fcc67b59148c234bc6dd75d0e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3b5f5f62023c9f197bf5c030b009f3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4f3b5f5f62023c9f197bf5c030b009f3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a4f3b5f5f62023c9f197bf5c030b009f3">success</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:a4f3b5f5f62023c9f197bf5c030b009f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object that is implicitly convertible to a succesful IOResult.  <a href="namespaceepi.html#a4f3b5f5f62023c9f197bf5c030b009f3">More...</a><br /></td></tr>
<tr class="separator:a4f3b5f5f62023c9f197bf5c030b009f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0088307255fc1f637105e021df538a5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a0088307255fc1f637105e021df538a5c">sum_nodes</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;ensemble_result)</td></tr>
<tr class="separator:a0088307255fc1f637105e021df538a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483d09848b2a8a36d8c9cc53c5320097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classepi_1_1RandomNumberGenerator.html">RandomNumberGenerator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a483d09848b2a8a36d8c9cc53c5320097">thread_local_rng</a> ()</td></tr>
<tr class="memdesc:a483d09848b2a8a36d8c9cc53c5320097"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a random number generator that is static and local to this thread.  <a href="namespaceepi.html#a483d09848b2a8a36d8c9cc53c5320097">More...</a><br /></td></tr>
<tr class="separator:a483d09848b2a8a36d8c9cc53c5320097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857d9dfd1881502919d7dca04d65b73f"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:a857d9dfd1881502919d7dca04d65b73f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a857d9dfd1881502919d7dca04d65b73f">unused</a> (T &amp;&amp;...)</td></tr>
<tr class="memdesc:a857d9dfd1881502919d7dca04d65b73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">does nothing, can be used to mark variables as not used.  <a href="namespaceepi.html#a857d9dfd1881502919d7dca04d65b73f">More...</a><br /></td></tr>
<tr class="separator:a857d9dfd1881502919d7dca04d65b73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cc48c909d42717f5ea6b15767b7ca1"><td class="memTemplParams" colspan="2">template&lt;class Model &gt; </td></tr>
<tr class="memitem:ab2cc48c909d42717f5ea6b15767b7ca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ab2cc48c909d42717f5ea6b15767b7ca1">write_graph</a> (const <a class="el" href="classepi_1_1Graph.html">Graph</a>&lt; Model, <a class="el" href="classepi_1_1MigrationParameters.html">MigrationParameters</a> &gt; &amp;graph, const std::string &amp;directory, int ioflags=<a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a>)</td></tr>
<tr class="memdesc:ab2cc48c909d42717f5ea6b15767b7ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates json files for each node in a simulation graph.  <a href="namespaceepi.html#ab2cc48c909d42717f5ea6b15767b7ca1">More...</a><br /></td></tr>
<tr class="separator:ab2cc48c909d42717f5ea6b15767b7ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b4e70ad6fc1980e0cc4e4c3dd8540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ae41b4e70ad6fc1980e0cc4e4c3dd8540">write_json</a> (const std::string &amp;path, const Json::Value &amp;js_value)</td></tr>
<tr class="memdesc:ae41b4e70ad6fc1980e0cc4e4c3dd8540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the json value into a file.  <a href="namespaceepi.html#ae41b4e70ad6fc1980e0cc4e4c3dd8540">More...</a><br /></td></tr>
<tr class="separator:ae41b4e70ad6fc1980e0cc4e4c3dd8540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aef7086e16a8429d491b36e706c2cd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac3aef7086e16a8429d491b36e706c2cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#ac3aef7086e16a8429d491b36e706c2cd">write_json</a> (const std::string &amp;path, const T &amp;t, int flags=<a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a>)</td></tr>
<tr class="memdesc:ac3aef7086e16a8429d491b36e706c2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object into json and write it into a file.  <a href="namespaceepi.html#ac3aef7086e16a8429d491b36e706c2cd">More...</a><br /></td></tr>
<tr class="separator:ac3aef7086e16a8429d491b36e706c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291d75c53062273651edb8b64455d144"><td class="memTemplParams" colspan="2">template&lt;class Simulation &gt; </td></tr>
<tr class="memitem:a291d75c53062273651edb8b64455d144"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceepi.html#a291d75c53062273651edb8b64455d144">write_single_run_result</a> (const int run, const <a class="el" href="classepi_1_1Graph.html">epi::Graph</a>&lt; <a class="el" href="classepi_1_1SimulationNode.html">epi::SimulationNode</a>&lt; <a class="el" href="classepi_1_1Simulation.html">Simulation</a> &gt;, <a class="el" href="classepi_1_1MigrationEdge.html">epi::MigrationEdge</a> &gt; &amp;graph)</td></tr>
<tr class="memdesc:a291d75c53062273651edb8b64455d144"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates xml file with a single run parameter study with std 0 (used to save parameters of individual runs)  <a href="namespaceepi.html#a291d75c53062273651edb8b64455d144">More...</a><br /></td></tr>
<tr class="separator:a291d75c53062273651edb8b64455d144"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa18a8a514f71a62488fa878d3a1e281d"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceepi.html#aa18a8a514f71a62488fa878d3a1e281d">INVALID_LOCATION_INDEX</a> = std::numeric_limits&lt;uint32_t&gt;::<a class="el" href="namespaceepi.html#ad671e5cd3a4ab1b63f066b3b7d4e7e2f">max</a>()</td></tr>
<tr class="separator:aa18a8a514f71a62488fa878d3a1e281d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file describes the framework for IO. </p>
<p>A collection of classes to simplify handling of matrix shapes in meta programming.</p>
<p>The framework is format-independent, all the format specific implementations are in the epidemiology_io library.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Main functions and types:</h2>
<ul>
<li>functions serialize and deserialize: Main entry points to the framework to write and read values, respectively. The functions expect an IOContext (see Concepts below) that stores the serialized data. (De-)serialization can be customized by providing a (de-)serialize_internal overload or a (de-)serialize member function for the type. See the section "Implementing 
     serialization for a new type" or the documentation for <code>serialize</code> and <code>deserialize</code>.</li>
<li><a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> and IOResult: Used for error handling, see section "Error Handling" below.</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Concepts:</h2>
<ol type="1">
<li>IOContext Stores data that describes serialized objects of any type in some unspecified format and provides structured access to the data for deserialization. Implementations of this concept may store the data in any format they want including binary. The data may also be written directly to disk. The context also keeps track of errors. An IOContext object <code>io</code> allows the following operations:</li>
</ol>
<ul>
<li><code>io.create_object("Type")</code>: Returns an IOObject for the type called <code>"Type"</code>. The IOObject (see below) allows adding data that describes the object to be serialized. The function must return something that can be assigned to a local variable, e.g., a temporary or copyable function. IOObject may store references to the context internally, so the lifetime of the local IOObject may not exceed the lifetime of the IOContext that created it.</li>
<li><code>io.expect_object("Type")</code>: Returns an IOObject for the type called <code>"Type"</code>. The IOObject (see below) provides access to the data needed for deserialization.</li>
<li><code>io.flags()</code>: Returns the flags that determine the behavior of serialization; see IOFlags.</li>
<li><code>io.error()</code>: Returns an <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> object to check if there were any errors during serialization. Usually it is not necessary to check this manually but can be used to report the error faster and avoid expensive operations that would be wasted anyway.</li>
<li><code>io.set_error(s)</code> with some <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> object: Stores an error that was generated outside of the IOContext, e.g., if a value that was deserialized is outside an allowed range.</li>
</ul>
<ol type="1">
<li>IOObject Gives structured access to serialized data. During serialization, data can be added with <code>add_...</code> operations. During deserialization, data can be retrieved with <code>expect_...</code> operations. Data must be retrieved in the same order as it was added since, e.g., binary format does not allow lookup by key. The following operations are supported for an IOObject <code>obj</code>:</li>
</ol>
<ul>
<li><code>obj.add_element("Name", t)</code>: Stores an object <code>t</code> in the IOObject under the key "Name". If <code>t</code> is of basic type (i.e., int, string), IOObject is expected to handle it directly. Otherwise, the object uses <code><a class="el" href="namespaceepi.html#ab7695ed10dce7f77ba45a6a208aa801c" title="Save data that describes an object in a format determined by the given context.">epi::serialize</a></code> to get the data for <code>t</code>.</li>
<li><code>obj.add_list("Name", b, e)</code>: Stores the elements in the range represented by iterators <code>b</code> and <code>e</code> under the key "Name". The individual elements are not named. The elements are either handled directly by the IOObject or using <code><a class="el" href="namespaceepi.html#ab7695ed10dce7f77ba45a6a208aa801c" title="Save data that describes an object in a format determined by the given context.">epi::serialize</a></code> just like <code>add_element</code>.</li>
<li><code>obj.add_optional("Name", p)</code>: Stores the element pointed to by pointer <code>p</code> under the key "Name". The pointer may be null. Otherwise identical to add_element.</li>
<li><code>obj.expect_element("Name", Tag&lt;T&gt;{})</code>: If an object of type T can be found under the key "Name" and can be deserialized, returns the object. Otherwise returns an error. Analogously to serialization, the IOObject is expected to handle basic types directly and use <code><a class="el" href="namespaceepi.html#a9e11480551689fac0a957df08e757bf9" title="Restores an object from the data stored in an IO context.">epi::deserialize</a></code> otherwise.</li>
<li><code>obj.expect_list("Name", Tag&lt;T&gt;{})</code>: If a list of objects of type T can be found under the key "Name" and can be deserialized, returns a range that can be iterated over. Otherwise returns an error.</li>
<li><code>obj.expect_optional("Name", Tag&lt;T&gt;{})</code>: Returns boost::optional&lt;T&gt; if an optional value of type T can be found under the key "Name". The optional may contain a value or it may be empty. Otherwise returns an error. Note that for some formats a wrong key is indistinguishable from an empty optional, so make sure to provide the correct key.</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
Error handling:</h2>
<p>Errors are handled by returning error codes. The type <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> contains an error code and an optional string with additional information. The type IOResult contains either a value or an <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> that describes an error. Operations that can fail return an IOResult&lt;T&gt; where T is the type of the value that is produced by the operation if it is succesful. Except where necessary because of dependencies, the framework does not throw nor catch any exceptions. IOContext and IOObject implementations are expected to store errors. During serialization, <code>add_...</code> operations fail without returning errors, but the error is stored in the IOObject and subsequent calls are usually no-ops. During deserialization, the values produced must usually be used or inspected, so <code>expect_...</code> operations return an IOResult. The <code>apply</code> utility function provides a simple way to inspect the result of multiple <code>expect_...</code> operations and use the values if all are succesful. See the documentation of <code><a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a></code>, <code>IOResult</code> and <code>apply</code> below for more details.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Implementing serialization for a new type:</h2>
<p>Serialization of a new type T can be customized by providing <em>either</em> member functions <code>serialize</code> and <code>deserialize</code> <em>or</em> free functions <code>serialize_internal</code> and <code>deserialize_internal</code>.</p>
<p>The <code>void serialize(IOContext&amp; io)</code> member function takes an IO context and uses <code>create_object</code> and <code>add_...</code> operations to add data. The static <code>IOResult&lt;T&gt; deserialize(IOContext&amp; io)</code> member function takes an IO context and uses <code>expect_...</code> operations to retrieve the data. The <code>apply</code> utility function can be used to inspect the result of the <code>expect_...</code> operations and construct the object of type T. E.g.: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> IOContext&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceepi.html#ab7695ed10dce7f77ba45a6a208aa801c">serialize</a>(IOContext&amp; io) {</div>
<div class="line">    <span class="keyword">auto</span> obj = io.create_object(<span class="stringliteral">&quot;Foo&quot;</span>);</div>
<div class="line">    obj.add_element(<span class="stringliteral">&quot;i&quot;</span>, i);</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> IOContext&gt;</div>
<div class="line">  <span class="keyword">static</span> IOResult&lt;Foo&gt; <a class="code" href="namespaceepi.html#a9e11480551689fac0a957df08e757bf9">deserialize</a>(IOContext&amp; io) {</div>
<div class="line">    <span class="keyword">auto</span> obj = io.expect_object(<span class="stringliteral">&quot;Foo&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> i_result = obj.expect_element(<span class="stringliteral">&quot;i&quot;</span>, <a class="code" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">epi::Tag&lt;int&gt;</a>{});</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceepi.html#a15a2504363f09ad496faf88547925bef">epi::apply</a>(io, [](<span class="keyword">auto</span>&amp;&amp; i) { <span class="keywordflow">return</span> Foo{i}; }, i_result);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The free functions <code>serialize_internal</code> and <code>deserialize_internal</code> must be found with argument dependent lookup (ADL). They can be used if no member function should or can be added to the type. See the code below for examples where this was done for, e.g., Eigen3 matrices and STL containers.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Adding a new serialization format:</h2>
<p>Implement concepts IOContext and IOObject that provide the operations listed above. Your implemenation should handle all built in types as well as std::string. It may handle other types (e.g., STL containers) as well if it can do so more efficiently than the provided general free functions. See the <a class="el" href="classepi_1_1JsonSerializer.html" title="Main class for (de-)serialization from/into json.">JsonSerializer</a> implementation in the epidemiology_io library for an example.</p>
<p>Matrix shape types follow this model:</p><ul>
<li>subtype Matrix that is an alias of an Eigen matrix type</li>
<li>at least one constructor that sets the shape from dimensions</li>
<li>static member function <code>get_shape_of</code> that takes a compatible matrix expression and returns it's shape</li>
<li>const member functions rows() and cols()</li>
<li>trivially copyable, moveable, assignable, move assignable</li>
<li>equality comparable </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a6b1a9c4fa2e196c5559ef49ec1a5853c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1a9c4fa2e196c5559ef49ec1a5853c">&#9670;&nbsp;</a></span>AbmMigrationParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">epi::AbmMigrationParameters</a> = typedef <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt;<a class="el" href="structepi_1_1LockdownDate.html">LockdownDate</a>, <a class="el" href="structepi_1_1SocialEventRate.html">SocialEventRate</a>, <a class="el" href="structepi_1_1BasicShoppingRate.html">BasicShoppingRate</a>, <a class="el" href="structepi_1_1WorkRatio.html">WorkRatio</a>, <a class="el" href="structepi_1_1SchoolRatio.html">SchoolRatio</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parameters that control the migration between locations. </p>

</div>
</div>
<a id="ae72f9828b941664722d9bbcfb06b0661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72f9828b941664722d9bbcfb06b0661">&#9670;&nbsp;</a></span>advance_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#ae72f9828b941664722d9bbcfb06b0661">epi::advance_expr_t</a> = typedef decltype(std::declval&lt;Sim&gt;().advance(std::declval&lt;double&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the return type of the <code>advance</code> member function of a type. </p>
<p>Template is invalid if this member function does not exist. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sim</td><td>a compartment model simulation type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5cdc2b2829dc3bd19041971a6cf5a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cdc2b2829dc3bd19041971a6cf5a95">&#9670;&nbsp;</a></span>ConstParameterDistributionVisitor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#af5cdc2b2829dc3bd19041971a6cf5a95">epi::ConstParameterDistributionVisitor</a> = typedef <a class="el" href="structepi_1_1ConstVisitor.html">ConstVisitor</a>&lt;class <a class="el" href="classepi_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a>, class <a class="el" href="classepi_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e98c1a8155e93a5806cfb554c16ec23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e98c1a8155e93a5806cfb554c16ec23">&#9670;&nbsp;</a></span>CVPlainMatrixT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a6e98c1a8155e93a5806cfb554c16ec23">epi::CVPlainMatrixT</a> = typedef typename <a class="el" href="structepi_1_1CVPlainMatrix.html">CVPlainMatrix</a>&lt;M&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e728d6aa323ae9211af40b1ea030abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e728d6aa323ae9211af40b1ea030abe">&#9670;&nbsp;</a></span>DerivFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a7e728d6aa323ae9211af40b1ea030abe">epi::DerivFunction</a> = typedef std::function&lt;void(Eigen::Ref&lt;const Eigen::VectorXd&gt; y, double t, Eigen::Ref&lt;Eigen::VectorXd&gt; dydt)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function template to be integrated. </p>

</div>
</div>
<a id="a18f4be98ec89a4bda1a78544c1f970b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f4be98ec89a4bda1a78544c1f970b4">&#9670;&nbsp;</a></span>deserialize_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a18f4be98ec89a4bda1a78544c1f970b4">epi::deserialize_t</a> = typedef decltype(T::deserialize(std::declval&lt;IOContext&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a605eb0c2d8ac500f6628f75dc4f86c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605eb0c2d8ac500f6628f75dc4f86c66">&#9670;&nbsp;</a></span>DiscreteDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a605eb0c2d8ac500f6628f75dc4f86c66">epi::DiscreteDistribution</a> = typedef <a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a>&lt;<a class="el" href="classepi_1_1DiscreteDistributionInPlace.html">DiscreteDistributionInPlace</a>&lt;Int&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted discrete distribution </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classepi_1_1DistributionAdapter.html" title="adapter for a random number distribution.">DistributionAdapter</a> </dd></dl>

</div>
</div>
<a id="aaa11e9378f9ab3f969265bd89ee9b441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa11e9378f9ab3f969265bd89ee9b441">&#9670;&nbsp;</a></span>eq_op_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aaa11e9378f9ab3f969265bd89ee9b441">epi::eq_op_t</a> = typedef decltype(std::declval&lt;T&gt;() == std::declval&lt;T&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>meta function to check type T for an existing equality comparison operator </p>

</div>
</div>
<a id="aa0cac98c077908bc007398f4ad7b1529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cac98c077908bc007398f4ad7b1529">&#9670;&nbsp;</a></span>eval_right_hand_side_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aa0cac98c077908bc007398f4ad7b1529">epi::eval_right_hand_side_expr_t</a> = typedef decltype(std::declval&lt;const M&amp;&gt;().eval_right_hand_side( std::declval&lt;Eigen::Ref&lt;const Eigen::VectorXd&gt; &gt;(), std::declval&lt;Eigen::Ref&lt;const Eigen::VectorXd&gt; &gt;(), std::declval&lt;double&gt;(), std::declval&lt;Eigen::Ref&lt;Eigen::VectorXd&gt; &gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect the eval_right_hand_side member function of a compartment model. </p>
<p>If the eval_right_hand_side member function exists in the type M, this template when instatiated will be equal to the return type of the function. Otherwise the template is invalid. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a type that has a eval_right_hand_side member function, e.g. a compartment model type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3758b0557953769d38a123a7a855d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3758b0557953769d38a123a7a855d41">&#9670;&nbsp;</a></span>ExponentialDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#ad3758b0557953769d38a123a7a855d41">epi::ExponentialDistribution</a> = typedef <a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a>&lt;std::exponential_distribution&lt;Real&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted std::exponential_distribution. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classepi_1_1DistributionAdapter.html" title="adapter for a random number distribution.">DistributionAdapter</a> </dd></dl>

</div>
</div>
<a id="a68eae9cbb50977de4b8bc824cb8cf300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68eae9cbb50977de4b8bc824cb8cf300">&#9670;&nbsp;</a></span>get_infections_relative_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a68eae9cbb50977de4b8bc824cb8cf300">epi::get_infections_relative_expr_t</a> = typedef decltype(<a class="el" href="namespaceepi.html#ac5aaa132a35ad0befebd665dac41fa7b">get_infections_relative</a>( std::declval&lt;const Sim&amp;&gt;(), std::declval&lt;double&gt;(), std::declval&lt;const Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect a get_infections_relative function for the Model type. </p>

</div>
</div>
<a id="a79c87ebcafdf586f5425535acb8cebd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c87ebcafdf586f5425535acb8cebd3">&#9670;&nbsp;</a></span>get_initial_values_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a79c87ebcafdf586f5425535acb8cebd3">epi::get_initial_values_expr_t</a> = typedef decltype(std::declval&lt;Eigen::VectorXd&amp;&gt;() = std::declval&lt;const M&amp;&gt;().get_initial_values())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect the get_initial_values member function of a compartment model. </p>
<p>If the detect_initial_values member function exists in the type M, this template when instatiated will be equal to the return type of the function. Otherwise the template is invalid. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a type that has a get_initial_values member function, e.g. a compartment model type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9d04ecebca75c2bfb37be13f5c08c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d04ecebca75c2bfb37be13f5c08c90">&#9670;&nbsp;</a></span>get_migration_factors_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#ac9d04ecebca75c2bfb37be13f5c08c90">epi::get_migration_factors_expr_t</a> = typedef decltype(<a class="el" href="namespaceepi.html#a175a57f9e3ae1cb3286ee8fa12382b21">get_migration_factors</a>( std::declval&lt;const Sim&amp;&gt;(), std::declval&lt;double&gt;(), std::declval&lt;const Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>detect a get_migration_factors function for the Model type. </p>

</div>
</div>
<a id="aa0d0e3dfee3b53f13540bc1bc9dbe590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d0e3dfee3b53f13540bc1bc9dbe590">&#9670;&nbsp;</a></span>GlobalInfectionParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aa0d0e3dfee3b53f13540bc1bc9dbe590">epi::GlobalInfectionParameters</a> = typedef <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt;<a class="el" href="structepi_1_1IncubationPeriod.html">IncubationPeriod</a>, <a class="el" href="structepi_1_1SusceptibleToExposedByCarrier.html">SusceptibleToExposedByCarrier</a>, <a class="el" href="structepi_1_1SusceptibleToExposedByInfected.html">SusceptibleToExposedByInfected</a>, <a class="el" href="structepi_1_1CarrierToInfected.html">CarrierToInfected</a>, <a class="el" href="structepi_1_1CarrierToRecovered.html">CarrierToRecovered</a>, <a class="el" href="structepi_1_1InfectedToRecovered.html">InfectedToRecovered</a>, <a class="el" href="structepi_1_1InfectedToSevere.html">InfectedToSevere</a>, <a class="el" href="structepi_1_1SevereToCritical.html">SevereToCritical</a>, <a class="el" href="structepi_1_1SevereToRecovered.html">SevereToRecovered</a>, <a class="el" href="structepi_1_1CriticalToDead.html">CriticalToDead</a>, <a class="el" href="structepi_1_1CriticalToRecovered.html">CriticalToRecovered</a>, <a class="el" href="structepi_1_1RecoveredToSusceptible.html">RecoveredToSusceptible</a>, <a class="el" href="structepi_1_1DetectInfection.html">DetectInfection</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parameters of the infection that are the same everywhere within the world. </p>

</div>
</div>
<a id="a3a7d0606b016adcad0609edaeba41571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7d0606b016adcad0609edaeba41571">&#9670;&nbsp;</a></span>has_apply_constraints_member_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a3a7d0606b016adcad0609edaeba41571">epi::has_apply_constraints_member_function</a> = typedef <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespaceepi_1_1details.html#a937466781a102b4c3e09b35b11aaa509">details::apply_constraints_expr_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a apply_constraints function exists </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type to check for the existence of the member function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3f523a014c9ab0d54aa44b016379e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f523a014c9ab0d54aa44b016379e57">&#9670;&nbsp;</a></span>has_check_constraints_member_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#ab3f523a014c9ab0d54aa44b016379e57">epi::has_check_constraints_member_function</a> = typedef <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespaceepi_1_1details.html#ac5f7e9186cba72e908b4e625a080b054">details::check_constraints_expr_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a check_constraints function exists </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type to check for the existence of the member function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af568a71f01950c9f9cff23e59571f1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af568a71f01950c9f9cff23e59571f1ee">&#9670;&nbsp;</a></span>has_eq_op</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">epi::has_eq_op</a> = typedef <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespaceepi.html#aaa11e9378f9ab3f969265bd89ee9b441">eq_op_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97485bd337bb3d17b03b77dae7a107d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97485bd337bb3d17b03b77dae7a107d5">&#9670;&nbsp;</a></span>has_get_default_member_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a97485bd337bb3d17b03b77dae7a107d5">epi::has_get_default_member_function</a> = typedef <a class="el" href="structepi_1_1details_1_1has__get__default__member__function.html">details::has_get_default_member_function</a>&lt;T, void, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether a get_default function exists </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type to check for the existence of the member function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab571ed7d1014cba00ba92c61dc5a729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab571ed7d1014cba00ba92c61dc5a729">&#9670;&nbsp;</a></span>has_ostream_op</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">epi::has_ostream_op</a> = typedef <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespaceepi.html#a546d8de8b1e1ed49bc560b0c3e076153">ostream_op_expr_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec4b1dbb8f2d81b0e5af433760fc156c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4b1dbb8f2d81b0e5af433760fc156c">&#9670;&nbsp;</a></span>InterpolateResultT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aec4b1dbb8f2d81b0e5af433760fc156c">epi::InterpolateResultT</a> = typedef std::decay_t&lt;decltype(<a class="el" href="namespaceepi.html#a9dfb5f0f7703e75e9667ff4bedcf5e97">interpolate_simulation_result</a>(std::declval&lt;T&gt;()))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper template, type returned by overload interpolate_simulation_result(T t) </p>

</div>
</div>
<a id="a89f5e00dd122b11fad06af0f2e72ee1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f5e00dd122b11fad06af0f2e72ee1a">&#9670;&nbsp;</a></span>IOResult</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">epi::IOResult</a> = typedef boost::outcome_v2::unchecked&lt;T, <a class="el" href="classepi_1_1IOStatus.html">IOStatus</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value-or-error type for operations that return a value but can fail. </p>
<p>Can also be used for functions that return void so that all IO functions have compatible signatures. e.g. <code>IOResult&lt;int&gt; parse_int(const std::string&amp; s);</code> <code>IOResult&lt;void&gt; mkdir(const std::string&amp; path);</code></p>
<p>Create IOResult objects with:</p><ul>
<li><code>success(t)</code>, <code>failure(e)</code>: Create objects that store a T or <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> and are implicitly convertible to IOResult. This is the easiest way to return from a function that returns an IOResult.</li>
<li>constructors: IOResult can normally be constructed directly from T or <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a>. If T is convertible to an error code (e.g. T = int), these constructors are disabled. There are constructors IOResult(Tag&lt;T&gt;{}, t) and IOResult(Tag&lt;IOStatus&gt;{}, e) that always work.</li>
</ul>
<p>Inspect the result with:</p><ul>
<li><code>operator bool()</code>: true if result represents success.</li>
<li><code>value()</code>: returns a reference to the value.</li>
<li><code>error()</code>: returns a reference to the error. <code>value()</code>/<code>error()</code> assert (terminate in debug mode) if the result is not succesful/not an error.</li>
</ul>
<p>When nesting functions that return IOResult, it is also possible to unpack the value and forward errors using the macro BOOST_OUTCOME_TRY. The statement <code>BOOST_OUTCOME_TRY(x, try_get_x());</code> is equivalent to the statements </p><div class="fragment"><div class="line"><span class="keyword">auto</span> result = try_get_x();</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">  <span class="keywordflow">return</span> result.as_failure();</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span>&amp;&amp; x = result.value();</div>
</div><!-- fragment --><p>This way, code the branches that are added for error handling are not visible in your code, the logic looks completely linear, e.g.: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> use_int(<span class="keywordtype">int</span> i);</div>
<div class="line">IOResult&lt;void&gt; parse_and_use_int(<span class="keyword">const</span> std::string&amp; s)</div>
<div class="line">{</div>
<div class="line">  BOOST_OUTCOME_TRY(i, parse_int(s));</div>
<div class="line">  use_int(i);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceepi.html#a4f628fcc67b59148c234bc6dd75d0e94">success</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The variable name can be omitted for operations that return IOResult&lt;void&gt;.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.boost.org/doc/libs/1_75_0/libs/outcome/doc/html/index.html">https://www.boost.org/doc/libs/1_75_0/libs/outcome/doc/html/index.html</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>type produced by an opertion that can fail. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec32ec82cdf215e82e31c870d65608cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec32ec82cdf215e82e31c870d65608cc">&#9670;&nbsp;</a></span>is_compartment_model</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aec32ec82cdf215e82e31c870d65608cc">epi::is_compartment_model</a> = typedef std::integral_constant&lt;bool, (<a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespaceepi.html#aa0cac98c077908bc007398f4ad7b1529">eval_right_hand_side_expr_t</a>, M&gt;::value &amp;&amp; <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespaceepi.html#a79c87ebcafdf586f5425535acb8cebd3">get_initial_values_expr_t</a>, M&gt;::value )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template meta function to check if a type is a valid compartment model. </p>
<p>Defines a static constant of name <code>value</code>. The constant <code>value</code> will be equal to true if M is a valid compartment model type. Otherwise, <code>value</code> will be equal to false. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sim</td><td>a type that may or may not be a compartment model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ff85b25e355a74c705c51c28bde8b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff85b25e355a74c705c51c28bde8b94">&#9670;&nbsp;</a></span>is_compartment_model_simulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a0ff85b25e355a74c705c51c28bde8b94">epi::is_compartment_model_simulation</a> = typedef std::integral_constant&lt;bool, (<a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespaceepi.html#ae72f9828b941664722d9bbcfb06b0661">advance_expr_t</a>, Sim&gt;::value &amp;&amp; <a class="el" href="namespaceepi.html#aec32ec82cdf215e82e31c870d65608cc">is_compartment_model</a>&lt;typename Sim::Model&gt;::value)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template meta function to check if a type is a compartment model simulation. </p>
<p>Defines a static constant of name <code>value</code>. The constant <code>value</code> will be equal to true if Sim is a valid compartment simulation type. Otherwise, <code>value</code> will be equal to false. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sim</td><td>a type that may or may not be a compartment model simulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a90efeb8b830c7399e938725425fbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a90efeb8b830c7399e938725425fbd8">&#9670;&nbsp;</a></span>is_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a7a90efeb8b830c7399e938725425fbd8">epi::is_container</a> = typedef <a class="el" href="structepi_1_1is__expression__valid.html">is_expression_valid</a>&lt;<a class="el" href="namespaceepi_1_1details.html#a123bb608d46e6515087c6098d2cc9b50">details::compare_iterators_t</a>, C&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is std::true_type if C is a STL compatible container. </p>
<p>Is std::false_type otherwise. See <a href="https://en.cppreference.com/w/cpp/named_req/Container">https://en.cppreference.com/w/cpp/named_req/Container</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>any type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50ee8ed255776fe210e3202ac4bd1a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ee8ed255776fe210e3202ac4bd1a4d">&#9670;&nbsp;</a></span>is_matrix_expression</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a50ee8ed255776fe210e3202ac4bd1a4d">epi::is_matrix_expression</a> = typedef std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template utility. </p>
<p>Defines value = true if M is an Eigen matrix expression. Defines value = false, otherwise. </p>

</div>
</div>
<a id="aa13162531b7e44e0c336c8026d145565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13162531b7e44e0c336c8026d145565">&#9670;&nbsp;</a></span>is_no_default_init_tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aa13162531b7e44e0c336c8026d145565">epi::is_no_default_init_tag</a> = typedef std::is_same&lt;<a class="el" href="structepi_1_1NoDefaultInit.html">NoDefaultInit</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b51b35a7ef8c9949fb5b0a1d24aa930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b51b35a7ef8c9949fb5b0a1d24aa930">&#9670;&nbsp;</a></span>is_small_integral</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a9b51b35a7ef8c9949fb5b0a1d24aa930">epi::is_small_integral</a> = typedef std::integral_constant&lt;bool, (std::is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) &lt;= 4)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f48f3e7d3f0fb94f9957174efa2903e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f48f3e7d3f0fb94f9957174efa2903e">&#9670;&nbsp;</a></span>LocalInfectionParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a0f48f3e7d3f0fb94f9957174efa2903e">epi::LocalInfectionParameters</a> = typedef <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt;<a class="el" href="structepi_1_1EffectiveContacts.html">EffectiveContacts</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parameters of the infection that depend on the location. </p>

</div>
</div>
<a id="a61f190cfe8f0c5c5d510179e8ca5c33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f190cfe8f0c5c5d510179e8ca5c33d">&#9670;&nbsp;</a></span>MigrationCoefficientGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a61f190cfe8f0c5c5d510179e8ca5c33d">epi::MigrationCoefficientGroup</a> = typedef <a class="el" href="classepi_1_1DampingMatrixExpressionGroup.html">DampingMatrixExpressionGroup</a>&lt;<a class="el" href="namespaceepi.html#a07f9e7d4ac440ba9752d0fb54e3d51d2">MigrationCoefficients</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sum of time dependent migration coefficients. </p>
<p>differentiate between sources of migration. </p>

</div>
</div>
<a id="a07f9e7d4ac440ba9752d0fb54e3d51d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f9e7d4ac440ba9752d0fb54e3d51d2">&#9670;&nbsp;</a></span>MigrationCoefficients</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a07f9e7d4ac440ba9752d0fb54e3d51d2">epi::MigrationCoefficients</a> = typedef <a class="el" href="classepi_1_1DampingMatrixExpression.html">DampingMatrixExpression</a>&lt;<a class="el" href="namespaceepi.html#a63fa4d5a798f1c6bf3d131245edd2f7b">VectorDampings</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>time dependent migration coefficients. </p>

</div>
</div>
<a id="a546d8de8b1e1ed49bc560b0c3e076153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546d8de8b1e1ed49bc560b0c3e076153">&#9670;&nbsp;</a></span>ostream_op_expr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a546d8de8b1e1ed49bc560b0c3e076153">epi::ostream_op_expr_t</a> = typedef decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>meta function to check type T for an existing stream output operator "&lt;&lt;" </p>

</div>
</div>
<a id="a614538fbd4acda827fea8ce8a10ca15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614538fbd4acda827fea8ce8a10ca15e">&#9670;&nbsp;</a></span>ParameterDistributionVisitor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a614538fbd4acda827fea8ce8a10ca15e">epi::ParameterDistributionVisitor</a> = typedef <a class="el" href="structepi_1_1Visitor.html">Visitor</a>&lt;class <a class="el" href="classepi_1_1ParameterDistributionNormal.html">ParameterDistributionNormal</a>, class <a class="el" href="classepi_1_1ParameterDistributionUniform.html">ParameterDistributionUniform</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a visitor class to visit all Parameter Distribution objects. </p>
<p>More information to the visitor pattern is here: <a href="https://en.wikipedia.org/wiki/Visitor_pattern">https://en.wikipedia.org/wiki/Visitor_pattern</a> </p>

</div>
</div>
<a id="aaaaf34550f501bb3ebc7e30b21f691a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaf34550f501bb3ebc7e30b21f691a2">&#9670;&nbsp;</a></span>ParameterTag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, class ParamSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aaaaf34550f501bb3ebc7e30b21f691a2">epi::ParameterTag</a> = typedef <a class="el" href="structepi_1_1details_1_1ParameterTag.html">details::ParameterTag</a>&lt;I, ParamSet&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the the tag of the I-th parameter in a set </p>

</div>
</div>
<a id="ad5971707e01729b665aac54c7161922f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5971707e01729b665aac54c7161922f">&#9670;&nbsp;</a></span>ParameterTagT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, class ParamSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#ad5971707e01729b665aac54c7161922f">epi::ParameterTagT</a> = typedef typename <a class="el" href="namespaceepi.html#aaaaf34550f501bb3ebc7e30b21f691a2">ParameterTag</a>&lt;I, ParamSet&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c199d53d5376dd9714e6c391d49e81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c199d53d5376dd9714e6c391d49e81d">&#9670;&nbsp;</a></span>SecirParamsBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a6c199d53d5376dd9714e6c391d49e81d">epi::SecirParamsBase</a> = typedef <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt;<a class="el" href="structepi_1_1StartDay.html">StartDay</a> ,<a class="el" href="structepi_1_1Seasonality.html">Seasonality</a> ,<a class="el" href="structepi_1_1ICUCapacity.html">ICUCapacity</a> ,<a class="el" href="structepi_1_1TestAndTraceCapacity.html">TestAndTraceCapacity</a> ,<a class="el" href="structepi_1_1ContactPatterns.html">ContactPatterns</a> ,<a class="el" href="structepi_1_1DynamicNPIsInfected.html">DynamicNPIsInfected</a> ,<a class="el" href="structepi_1_1IncubationTime.html">IncubationTime</a> ,<a class="el" href="structepi_1_1InfectiousTimeMild.html">InfectiousTimeMild</a> ,<a class="el" href="structepi_1_1InfectiousTimeAsymptomatic.html">InfectiousTimeAsymptomatic</a> ,<a class="el" href="structepi_1_1SerialInterval.html">SerialInterval</a> ,<a class="el" href="structepi_1_1HospitalizedToHomeTime.html">HospitalizedToHomeTime</a> ,<a class="el" href="structepi_1_1HomeToHospitalizedTime.html">HomeToHospitalizedTime</a> ,<a class="el" href="structepi_1_1HospitalizedToICUTime.html">HospitalizedToICUTime</a> ,<a class="el" href="structepi_1_1ICUToHomeTime.html">ICUToHomeTime</a> ,<a class="el" href="structepi_1_1ICUToDeathTime.html">ICUToDeathTime</a> ,<a class="el" href="structepi_1_1InfectionProbabilityFromContact.html">InfectionProbabilityFromContact</a> ,<a class="el" href="structepi_1_1RelativeCarrierInfectability.html">RelativeCarrierInfectability</a> ,<a class="el" href="structepi_1_1AsymptoticCasesPerInfectious.html">AsymptoticCasesPerInfectious</a> ,<a class="el" href="structepi_1_1RiskOfInfectionFromSympomatic.html">RiskOfInfectionFromSympomatic</a> ,<a class="el" href="structepi_1_1MaxRiskOfInfectionFromSympomatic.html">MaxRiskOfInfectionFromSympomatic</a> ,<a class="el" href="structepi_1_1HospitalizedCasesPerInfectious.html">HospitalizedCasesPerInfectious</a> ,<a class="el" href="structepi_1_1ICUCasesPerHospitalized.html">ICUCasesPerHospitalized</a> ,<a class="el" href="structepi_1_1DeathsPerHospitalized.html">DeathsPerHospitalized</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3b893d23c35e69d8abb33b3ab79e07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b893d23c35e69d8abb33b3ab79e07b">&#9670;&nbsp;</a></span>SeirParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#ac3b893d23c35e69d8abb33b3ab79e07b">epi::SeirParameters</a> = typedef <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt;<a class="el" href="structepi_1_1TransmissionRisk.html">TransmissionRisk</a>, <a class="el" href="structepi_1_1StageTimeIncubationInv.html">StageTimeIncubationInv</a>, <a class="el" href="structepi_1_1StageTimeInfectiousInv.html">StageTimeInfectiousInv</a>, <a class="el" href="structepi_1_1ContactFrequency.html">ContactFrequency</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b5810f8faae7ca1509383c09026c03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5810f8faae7ca1509383c09026c03b">&#9670;&nbsp;</a></span>SeirPopulations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a0b5810f8faae7ca1509383c09026c03b">epi::SeirPopulations</a> = typedef <a class="el" href="classepi_1_1Populations.html">Populations</a>&lt;<a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cba">SeirInfType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66d78f82897c5bcd59f9a1a4dc60db35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d78f82897c5bcd59f9a1a4dc60db35">&#9670;&nbsp;</a></span>serialize_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a66d78f82897c5bcd59f9a1a4dc60db35">epi::serialize_t</a> = typedef decltype(std::declval&lt;T&gt;().<a class="el" href="namespaceepi.html#ab7695ed10dce7f77ba45a6a208aa801c">serialize</a>(std::declval&lt;IOContext&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94de3505cb1d61b182329474c9d5e444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94de3505cb1d61b182329474c9d5e444">&#9670;&nbsp;</a></span>SquareDamping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a94de3505cb1d61b182329474c9d5e444">epi::SquareDamping</a> = typedef <a class="el" href="classepi_1_1Damping.html">Damping</a>&lt;<a class="el" href="classepi_1_1SquareMatrixShape.html">SquareMatrixShape</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>aliases for common damping specializations. </p>

</div>
</div>
<a id="a95892d0984ef6d2c218fb2f6ee278b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95892d0984ef6d2c218fb2f6ee278b22">&#9670;&nbsp;</a></span>SquareDampings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a95892d0984ef6d2c218fb2f6ee278b22">epi::SquareDampings</a> = typedef <a class="el" href="classepi_1_1Dampings.html">Dampings</a>&lt;<a class="el" href="namespaceepi.html#a94de3505cb1d61b182329474c9d5e444">SquareDamping</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6c8b9491165ac4a30ac7f9208975056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c8b9491165ac4a30ac7f9208975056">&#9670;&nbsp;</a></span>Tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">epi::Tag</a> = typedef boost::outcome_v2::in_place_type_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type that is used for overload resolution. </p>
<p>Use as dummy arguments to resolve overloads that would otherwise only differ by return type and don't have any other arguments that allow resolution. e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> foo(Tag&lt;int&gt;);</div>
<div class="line"><span class="keywordtype">double</span> foo(Tag&lt;double&gt;);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a32c5e3fea7f9fc3b2ebc19ffdd1c5e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c5e3fea7f9fc3b2ebc19ffdd1c5e78">&#9670;&nbsp;</a></span>UniformDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a32c5e3fea7f9fc3b2ebc19ffdd1c5e78">epi::UniformDistribution</a> = typedef <a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a>&lt;std::uniform_real_distribution&lt;Real&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted uniform_real_distribution. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classepi_1_1DistributionAdapter.html" title="adapter for a random number distribution.">DistributionAdapter</a> </dd></dl>

</div>
</div>
<a id="a500acd4e2d9dcca2e2c3a77d3c99e4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500acd4e2d9dcca2e2c3a77d3c99e4b3">&#9670;&nbsp;</a></span>UniformIntDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a500acd4e2d9dcca2e2c3a77d3c99e4b3">epi::UniformIntDistribution</a> = typedef <a class="el" href="classepi_1_1DistributionAdapter.html">DistributionAdapter</a>&lt;std::uniform_int_distribution&lt;Int&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adapted std::uniform_int_distribution. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classepi_1_1DistributionAdapter.html" title="adapter for a random number distribution.">DistributionAdapter</a> </dd></dl>

</div>
</div>
<a id="aeca617f209ac030250a7a2ec56b8fee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca617f209ac030250a7a2ec56b8fee3">&#9670;&nbsp;</a></span>VectorDamping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#aeca617f209ac030250a7a2ec56b8fee3">epi::VectorDamping</a> = typedef <a class="el" href="classepi_1_1Damping.html">Damping</a>&lt;<a class="el" href="classepi_1_1ColumnVectorShape.html">ColumnVectorShape</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63fa4d5a798f1c6bf3d131245edd2f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fa4d5a798f1c6bf3d131245edd2f7b">&#9670;&nbsp;</a></span>VectorDampings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a63fa4d5a798f1c6bf3d131245edd2f7b">epi::VectorDampings</a> = typedef <a class="el" href="classepi_1_1Dampings.html">Dampings</a>&lt;<a class="el" href="namespaceepi.html#aeca617f209ac030250a7a2ec56b8fee3">VectorDamping</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a804ae3dfeddc7fe4c03beddd3feb4307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804ae3dfeddc7fe4c03beddd3feb4307">&#9670;&nbsp;</a></span>VisitableParameterDistribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a804ae3dfeddc7fe4c03beddd3feb4307">epi::VisitableParameterDistribution</a> = typedef <a class="el" href="structepi_1_1Visitable.html">Visitable</a>&lt;Derived, class <a class="el" href="classepi_1_1ParameterDistribution.html">ParameterDistribution</a>, <a class="el" href="namespaceepi.html#a614538fbd4acda827fea8ce8a10ca15e">ParameterDistributionVisitor</a>, <a class="el" href="namespaceepi.html#af5cdc2b2829dc3bd19041971a6cf5a95">ConstParameterDistributionVisitor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84f3bdea77e1a3e6eabe0b7f3b821382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f3bdea77e1a3e6eabe0b7f3b821382">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceepi.html#a84f3bdea77e1a3e6eabe0b7f3b821382">epi::void_t</a> = typedef typename <a class="el" href="structepi_1_1details_1_1make__void.html">details::make_void</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>utility for meta programming that produces void for any valid type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a784fce71eb260f60a05f83af3b93b29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784fce71eb260f60a05f83af3b93b29f">&#9670;&nbsp;</a></span>AbmAgeGroup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceepi.html#a784fce71eb260f60a05f83af3b93b29f">epi::AbmAgeGroup</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>age groups like RKI. </p>
<p>EXPERIMENTAL; will be merged with new model framework soon. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a784fce71eb260f60a05f83af3b93b29faecdef1978b0426a4dbce2482e4d992c0"></a>Age0to4&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a784fce71eb260f60a05f83af3b93b29fa0e635bc20a1ebd1d39528e24ad180ea6"></a>Age5to14&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a784fce71eb260f60a05f83af3b93b29fad94c53cbd84e5bb40ac92d58ecf410e1"></a>Age15to34&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a784fce71eb260f60a05f83af3b93b29fa1af7e3664451c7caa568fdc0fe9bbea7"></a>Age35to59&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a784fce71eb260f60a05f83af3b93b29fa256d02bd24303e832b43bc2c45b1ea8e"></a>Age60to79&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a784fce71eb260f60a05f83af3b93b29fadc550a7d96fee29c927fc5f8200a312a"></a>Age80plus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a784fce71eb260f60a05f83af3b93b29fae93f994f01c537c4e2f7d8528c3eb5e9"></a>Count&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a17593cd975761f387cc5b33364da2aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17593cd975761f387cc5b33364da2aae">&#9670;&nbsp;</a></span>InfectionState <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092">epi::InfectionState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The InfectionState enum describes the possible categories for the infectious state of persons. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea494bf3eaa390dc405dd04ed1c8c99311"></a>Susceptible&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaeaa54eecd5041d37f5c8443e0ee91e241a"></a>Exposed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea914419aa32f04011357d3b604a86d7eb"></a>Carrier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea36b9ceab1f9b08d33edcf6938502e668"></a>Infected_Detected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaeaae58548244582c05ad9a2b71d73b9fa2"></a>Infected_Undetected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea58bfe3d6d7066460b884407b8aa3e6ff"></a>Infected_Severe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaeaf6ffec455b098e0fd677c127981b5941"></a>Infected_Critical&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea24461bbbf6767efaceb04659c41b24cb"></a>Recovered_Carrier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaeadbfd2bf86aae96cb44cc667248dace3a"></a>Recovered_Infected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea183b62c7f067711f9c5a54913c054617"></a>Dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaeae93f994f01c537c4e2f7d8528c3eb5e9"></a>Count&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea494bf3eaa390dc405dd04ed1c8c99311"></a>Susceptible&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaeaa54eecd5041d37f5c8443e0ee91e241a"></a>Exposed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea914419aa32f04011357d3b604a86d7eb"></a>Carrier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaeae11a453510398112e5dba69d300da48b"></a>Infected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea6c8cd990c3a6f78e53faa743bee2850b"></a>Hospitalized&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea26bf7a7e68c0acc2c819ec1621630389"></a>ICU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea5c4c4cf7bbab0d76fe61420aee14a5ca"></a>Recovered&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaea183b62c7f067711f9c5a54913c054617"></a>Dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a17593cd975761f387cc5b33364da2aaeae93f994f01c537c4e2f7d8528c3eb5e9"></a>Count&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa085820f5ddc6774e7591ec0b5305092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa085820f5ddc6774e7591ec0b5305092">&#9670;&nbsp;</a></span>InfectionState <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092">epi::InfectionState</a> : std::uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>infection state in ABM. </p>
<p>can be used as 0-based index </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a494bf3eaa390dc405dd04ed1c8c99311"></a>Susceptible&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092aa54eecd5041d37f5c8443e0ee91e241a"></a>Exposed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a914419aa32f04011357d3b604a86d7eb"></a>Carrier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a36b9ceab1f9b08d33edcf6938502e668"></a>Infected_Detected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092aae58548244582c05ad9a2b71d73b9fa2"></a>Infected_Undetected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a58bfe3d6d7066460b884407b8aa3e6ff"></a>Infected_Severe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092af6ffec455b098e0fd677c127981b5941"></a>Infected_Critical&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a24461bbbf6767efaceb04659c41b24cb"></a>Recovered_Carrier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092adbfd2bf86aae96cb44cc667248dace3a"></a>Recovered_Infected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a183b62c7f067711f9c5a54913c054617"></a>Dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092ae93f994f01c537c4e2f7d8528c3eb5e9"></a>Count&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a494bf3eaa390dc405dd04ed1c8c99311"></a>Susceptible&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092aa54eecd5041d37f5c8443e0ee91e241a"></a>Exposed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a914419aa32f04011357d3b604a86d7eb"></a>Carrier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092ae11a453510398112e5dba69d300da48b"></a>Infected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a6c8cd990c3a6f78e53faa743bee2850b"></a>Hospitalized&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a26bf7a7e68c0acc2c819ec1621630389"></a>ICU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a5c4c4cf7bbab0d76fe61420aee14a5ca"></a>Recovered&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092a183b62c7f067711f9c5a54913c054617"></a>Dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa085820f5ddc6774e7591ec0b5305092ae93f994f01c537c4e2f7d8528c3eb5e9"></a>Count&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1bf67eb2c517123112248a0025645724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf67eb2c517123112248a0025645724">&#9670;&nbsp;</a></span>IOFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724">epi::IOFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flags to determine the behavior of the serialization process. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01"></a>IOF_None&#160;</td><td class="fielddoc"><p>default behavior. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1bf67eb2c517123112248a0025645724af2b4bcefd5e7aa65f7f3d6f9d81432cb"></a>IOF_OmitDistributions&#160;</td><td class="fielddoc"><p>Don't serialize distributions for types that contain both a specific value and a distribution from which new values can be sampled, e.g. </p>
<p><a class="el" href="classepi_1_1UncertainValue.html" title="The UncertainValue class consists of a scalar value and a Distribution object.">UncertainValue</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1bf67eb2c517123112248a0025645724a51a573ce09fe1f8dc1ccbcfacf3ba115"></a>IOF_OmitValues&#160;</td><td class="fielddoc"><p>Don't serialize the current value for types that contain both a specific value and a distribution from which new values can be sampled, e.g., <a class="el" href="classepi_1_1UncertainValue.html" title="The UncertainValue class consists of a scalar value and a Distribution object.">UncertainValue</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="adabd8b3f600e98668b14d2d891526943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabd8b3f600e98668b14d2d891526943">&#9670;&nbsp;</a></span>LocationType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">epi::LocationType</a> : std::uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>type of a location. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adabd8b3f600e98668b14d2d891526943a8cf04a9734132302f96da8e113e80ce5"></a>Home&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adabd8b3f600e98668b14d2d891526943a955cd8691ca89a6baa6ea10c7787e604"></a>School&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adabd8b3f600e98668b14d2d891526943a0f9263536b9fc61ada745644735bfd8f"></a>Work&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adabd8b3f600e98668b14d2d891526943a53ceef26ee8557fa2446a2596daed5c0"></a>SocialEvent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adabd8b3f600e98668b14d2d891526943a0c09a8f523b937dae1ff7e3588566465"></a>BasicsShop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adabd8b3f600e98668b14d2d891526943acc2ab63fd3eb564be64b4f21bd083bc7"></a>Hospital&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adabd8b3f600e98668b14d2d891526943a26bf7a7e68c0acc2c819ec1621630389"></a>ICU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adabd8b3f600e98668b14d2d891526943ae93f994f01c537c4e2f7d8528c3eb5e9"></a>Count&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4d44f54b29b6a8e746bef68135a3ac60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d44f54b29b6a8e746bef68135a3ac60">&#9670;&nbsp;</a></span>LogLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">epi::LogLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d44f54b29b6a8e746bef68135a3ac60a04a75036e9d520bb983c5ed03b8d0182"></a>trace&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d44f54b29b6a8e746bef68135a3ac60aad42f6697b035b7580e4fef93be20b4d"></a>debug&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d44f54b29b6a8e746bef68135a3ac60acaf9b6b99962bf5c2264824231d7a40c"></a>info&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d44f54b29b6a8e746bef68135a3ac60a1ea4c3ab05ee0c6d4de30740443769cb"></a>warn&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d44f54b29b6a8e746bef68135a3ac60a56bd7107802ebe56c6918992f0608ec6"></a>err&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d44f54b29b6a8e746bef68135a3ac60a7e85bcb66fb9a809d5ab4f62a8b8bea8"></a>critical&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d44f54b29b6a8e746bef68135a3ac60a3262d48df5d75e3452f0f16b313b7808"></a>off&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0ff5db7abe78b78015732f96de311cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff5db7abe78b78015732f96de311cba">&#9670;&nbsp;</a></span>SeirInfType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceepi.html#a0ff5db7abe78b78015732f96de311cba">epi::SeirInfType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0ff5db7abe78b78015732f96de311cbaa5dbc98dcc983a70728bd082d1a47546e"></a>S&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0ff5db7abe78b78015732f96de311cbaa3a3ea00cfc35332cedf6e5e9a32e94da"></a>E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0ff5db7abe78b78015732f96de311cbaadd7536794b63bf90eccfd37f9b147d7f"></a>I&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0ff5db7abe78b78015732f96de311cbaae1e1d3d40573127e9ee0480caf1283d6"></a>R&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0ff5db7abe78b78015732f96de311cbaae93f994f01c537c4e2f7d8528c3eb5e9"></a>Count&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1e26c2aefb564c12224c2dd16b1ba8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e26c2aefb564c12224c2dd16b1ba8ce">&#9670;&nbsp;</a></span>StatusCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ce">epi::StatusCode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>code to indicate the result of an operation. </p>
<p>convertible to std::error_code. see <a href="https://www.boost.org/doc/libs/1_75_0/libs/outcome/doc/html/motivation/plug_error_code.html">https://www.boost.org/doc/libs/1_75_0/libs/outcome/doc/html/motivation/plug_error_code.html</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1e26c2aefb564c12224c2dd16b1ba8ceae0aa021e21dddbd6d8cecec71e9cf564"></a>OK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e26c2aefb564c12224c2dd16b1ba8ceabfaef30f1c8011c5cefa38ae470fb7aa"></a>UnknownError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e26c2aefb564c12224c2dd16b1ba8cea365b2699d38b61ef4b4c8a1066c8468f"></a>OutOfRange&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e26c2aefb564c12224c2dd16b1ba8cea223e81e8afa42c41346a6696560ecc7b"></a>InvalidValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e26c2aefb564c12224c2dd16b1ba8ceade9a4832789ef70d5f9bee2a83345e8a"></a>InvalidFileFormat&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e26c2aefb564c12224c2dd16b1ba8ceaa645e4cfc8d16be330607ad52aec5f98"></a>KeyNotFound&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e26c2aefb564c12224c2dd16b1ba8ceac85f85f7c13ed006eed130ec183aa810"></a>InvalidType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e26c2aefb564c12224c2dd16b1ba8cea2767828026039e8ba7b38973cbb701f2"></a>FileNotFound&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af72dbc8ce3e0a9d0e576f9cfe6f5fed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72dbc8ce3e0a9d0e576f9cfe6f5fed4">&#9670;&nbsp;</a></span>abs_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T epi::abs_max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maximum absolute value of two numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first number </td></tr>
    <tr><td class="paramname">v2</td><td>second number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum absolute value between v1 and v2 </dd></dl>

</div>
</div>
<a id="a15a2504363f09ad496faf88547925bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a2504363f09ad496faf88547925bef">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class F , class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi_1_1details.html#a3fac1957f2e080c3a4198e55f33a434e">details::ApplyResultT</a>&lt;F, T...&gt; epi::apply </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; T &gt; &amp;...&#160;</td>
          <td class="paramname"><em>rs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a function with zero or more unpacked IOResults as arguments. </p>
<p>Returns an IOResult that contains the result of <code>f(rs.value()...)</code> if all IOResults <code>rs</code> contain a value. If any IOResult contains an error, that error is returned instead. The function f may return an object of any type U. It can also return IOResult<u> (e.g. to validate the values contained in the arguments). In either case, apply returns IOResult<u> and never any nested IOResult&lt;IOResult<u>&gt;. If apply returns an error, it is also stored in the given IO context so that the context is informed of e.g. validation errors that cannot be checked simply from the types and the format of the file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type with a set_error(const IOStatus&amp;) member function. </td></tr>
    <tr><td class="paramname">F</td><td>a type that has a function call operator with signature either <code>U F(T&amp;&amp;...)</code> or <code>IOResult&lt;U&gt; F(T&amp;&amp;...)</code> for any <code>U</code>. </td></tr>
    <tr><td class="paramname">T</td><td>zero ore more types of values contained in the IOResult arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IOContext that is notified of errors. </td></tr>
    <tr><td class="paramname">f</td><td>the function that is called with the values contained in <code>rs</code> as arguments. </td></tr>
    <tr><td class="paramname">rs</td><td>zero or more IOResults from previous operations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of f(rs.value()...) if successful, the first error encountered otherwise. </dd></dl>
<p></u></u></u></p>

</div>
</div>
<a id="a4c57f3648db1d2f23fa373b1c2deab2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c57f3648db1d2f23fa373b1c2deab2c">&#9670;&nbsp;</a></span>apply_dampings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingExpression , class DampingSamplings , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::apply_dampings </td>
          <td>(</td>
          <td class="paramtype">DampingExpression &amp;&#160;</td>
          <td class="paramname"><em>damping_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DampingSamplings &amp;&#160;</td>
          <td class="paramname"><em>dampings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>make_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add sampled dampings to a damping expression. </p>
<p>does not draw new random value, just adds dampings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damping_expression</td><td>e.g. contact matrix group. </td></tr>
    <tr><td class="paramname">dampings</td><td>sampled dampings. </td></tr>
    <tr><td class="paramname">make_mask</td><td>functor that creates a matrix from damping value weighted by group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e20cf9e16e9bac7d54b7b90bcd1b6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e20cf9e16e9bac7d54b7b90bcd1b6a3">&#9670;&nbsp;</a></span>apply_migration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::apply_migration </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>migrationEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge functor for migration simulation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classepi_1_1MigrationEdge.html#add3f55acb264880c82c0c28fc5a1babe" title="compute migration from node_from to node_to.">MigrationEdge::apply_migration</a> </dd></dl>

</div>
</div>
<a id="abbec4d09b91db02d1a5304e92933f3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbec4d09b91db02d1a5304e92933f3d4">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;::value, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, true&gt; &gt; epi::begin </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a const iterator to first element of the matrix m. </p>

</div>
</div>
<a id="a08e8b6a0525b440b6fcc4c958e4eb4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e8b6a0525b440b6fcc4c958e4eb4ef">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceepi.html#a9deae6f690facc4fe4d3d3641c1f0458">conjunction_v</a>&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;, <a class="el" href="namespaceepi_1_1details.html#addd30df2f588966f391bf5a9f25e3418">details::IsElementReference</a>&lt;M&gt; &gt;, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, false&gt; &gt; epi::begin </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a non-const iterator to first element of the matrix m. </p>
<p>only enabled if the matrix is evaluated in memory, i.e. elements can be modified. </p>

</div>
</div>
<a id="aea232b41c2d92933cb0907bd5ec59a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea232b41c2d92933cb0907bd5ec59a81">&#9670;&nbsp;</a></span>calculate_migration_returns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim , class  = std::enable_if_t&lt;is_compartment_model_simulation&lt;Sim&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::calculate_migration_returns </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;::Vector &gt;&#160;</td>
          <td class="paramname"><em>migrated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Sim &amp;&#160;</td>
          <td class="paramname"><em>sim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;::Vector &gt;&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjust number of migrated people when they return according to the model. </p>
<p>E.g. during the time in the other node, some people who left as susceptible will return exposed. Implemented for general compartmentmodel simulations, overload for your custom model if necessary so that it can be found with argument-dependent lookup, i.e. in the same namespace as the model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">migrated</td><td>number of people that migrated as input, number of people that return as output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>parameters of model in the node that the people migrated to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">total</td><td>total population in the node that the people migrated to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>time of migration </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dt</td><td>time between migration and return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a661a5a85ffb891dc858c47286f4ff992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661a5a85ffb891dc858c47286f4ff992">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;::value, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, true&gt; &gt; epi::cbegin </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a const iterator to first element of the matrix m. </p>

</div>
</div>
<a id="a17ae626c0e36715b86bc35ccbe5b5612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ae626c0e36715b86bc35ccbe5b5612">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;::value, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, true&gt; &gt; epi::cend </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a non-const end iterator for the matrix m. </p>

</div>
</div>
<a id="a19ddd084d167b1bc6933072ad6cb3d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ddd084d167b1bc6933072ad6cb3d34">&#9670;&nbsp;</a></span>close_social_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::close_social_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname"><em>t_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>During lockdown people join social events less often. </p>
<p>If a person joins a social event is a random event (exponentially distributed). The damping changes the parameter of the exponential distribution, where a damping of 0 corresponds to no damping and a damping of 1 means that no social events are happening. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_begin</td><td>begin of the intervention </td></tr>
    <tr><td class="paramname">p</td><td>damping between 0 and 1 that changes the parameter of the exponential distribution </td></tr>
    <tr><td class="paramname">params</td><td>migration parameters that include damping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a579d7464e37419ca1df9411caee4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a579d7464e37419ca1df9411caee4ae">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter , class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool epi::contains </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if there is an element in this range that matches a predicate </p>

</div>
</div>
<a id="a6b5123237a88879be47114904097da2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5123237a88879be47114904097da2c">&#9670;&nbsp;</a></span>count_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; int &gt; epi::count_lines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts lines of txt file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file which is counted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af67d2d9cff491983eb7023fd7b8120d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67d2d9cff491983eb7023fd7b8120d0">&#9670;&nbsp;</a></span>create_directory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; bool &gt; epi::create_directory </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>rel_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory in the file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel_path</td><td>path of directory relative to current working directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the directory was created, false if it already exists, or any errors that occured. </dd></dl>

</div>
</div>
<a id="a0f7ec077532895e9729cc5ae46470dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7ec077532895e9729cc5ae46470dd9">&#9670;&nbsp;</a></span>create_directory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; bool &gt; epi::create_directory </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>rel_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>abs_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory in the file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel_path</td><td>path of directory relative to current working directory. </td></tr>
    <tr><td class="paramname">abs_path</td><td>Will contain the absolute path of the directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the directory was created, false if it already exists, or any errors that occured. </dd></dl>

</div>
</div>
<a id="a1756628093347c730580c8fb835dd620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1756628093347c730580c8fb835dd620">&#9670;&nbsp;</a></span>days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a> epi::days </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>days</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a <a class="el" href="classepi_1_1TimeSpan.html" title="a duration of time.">TimeSpan</a> with a specified number of days. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>number of days in the time span. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8e10d63305d29ed86d6fa016006dd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e10d63305d29ed86d6fa016006dd52">&#9670;&nbsp;</a></span>DECL_TYPESAFE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">epi::DECL_TYPESAFE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingLevel&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>integer damping level. </p>

</div>
</div>
<a id="a1a12e1749121702a37fd801fcef335e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a12e1749121702a37fd801fcef335e8">&#9670;&nbsp;</a></span>DECL_TYPESAFE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">epi::DECL_TYPESAFE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>integer damping type. </p>

</div>
</div>
<a id="a9e11480551689fac0a957df08e757bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e11480551689fac0a957df08e757bf9">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; T &gt; epi::deserialize </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores an object from the data stored in an IO context. </p>
<p>There must be provided for the type T either a free function <code>deserialize_internal(io, tag)</code> that can be found using argument dependent lookup (ADL) or a static member function <code>T::deserialize(io)</code>. The <code>deserialize_internal</code> function or <code>deserialize</code> member function retrieve the data needed to restore the object from the IO context. The context provides the data if it can and keeps track of errors. <code>deserialize_internal</code> overloads are already provided for many common types, e.g. STL containers or Eigen Matrices. <code>serialize</code> and <code>deserialize</code> are the main entry points into this IO framework, but there may be more convenient functions provided for specific IO contexts. These functions are not expected to use ADL, so should be called namespace qualified. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">T</td><td>any deserializable type, i.e., that has a <code>deserialize</code> member function or <code>deserialize_internal</code> overload </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>IO context that contains the data for an object of type T </td></tr>
    <tr><td class="paramname">tag</td><td>specifies the type to be restored from the data, for overload resolution only. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the restored T if succesful, an error code otherwise. </dd></dl>

</div>
</div>
<a id="a1d51a7c94e53fd2cc4ecd3ace974a59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d51a7c94e53fd2cc4ecd3ace974a59f">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class Container , std::enable_if_t&lt;(is_container&lt; Container &gt;::value &amp;&amp;!is_expression_valid&lt; serialize_t, IOContext, Container &gt;::value), void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;Container&gt; epi::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; Container &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize an STL compatible container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">Container</td><td>the container type to be deserialized. A container is anything with begin and end iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the container to be serialized for overload resolution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>restored container if successful, error otherwise. </dd></dl>

</div>
</div>
<a id="aa414af8f1af5059823405afa21c7269a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa414af8f1af5059823405afa21c7269a">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class E , std::enable_if_t&lt; std::is_enum&lt; E &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;E&gt; epi::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; E &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize an enum value from its underlying type. </p>
<p>It is impossible to validate the range of the enum type, validate after if necessary. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">E</td><td>an enum type to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the enum to be deserialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an enum value if succesful, an error otherwise. </dd></dl>

</div>
</div>
<a id="ab553ce68883355a0bb6b03264d8b3ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab553ce68883355a0bb6b03264d8b3ab5">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class M , std::enable_if_t&lt; std::is_base_of&lt; Eigen::EigenBase&lt; M &gt;, M &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;M&gt; epi::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; M &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize an Eigen matrix. </p>
<p>It is possible to serialize an unevaluated expression, e.g. Eigen::MatrixXd::Constant(r, c, v). But it is (at least currently) not possible to deserialize it. Only matrices that own their memory can be deserialized. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">M</td><td>the type of Eigen matrix expression to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the matrix to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98d8a6e4671f2b07ef97b87f9572f81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d8a6e4671f2b07ef97b87f9572f81a">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;std::shared_ptr&lt;<a class="el" href="classepi_1_1ParameterDistribution.html">ParameterDistribution</a>&gt; &gt; epi::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; std::shared_ptr&lt; <a class="el" href="classepi_1_1ParameterDistribution.html">ParameterDistribution</a> &gt;&gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize a parameter distribution as a shared_ptr. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceepi.html#a9e11480551689fac0a957df08e757bf9" title="Restores an object from the data stored in an IO context.">epi::deserialize</a> </dd></dl>

</div>
</div>
<a id="a08113f6af9b3a80a22d62a320269b6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08113f6af9b3a80a22d62a320269b6c9">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T , std::enable_if_t&lt; is_expression_valid&lt; deserialize_t, IOContext, T &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;T&gt; epi::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; T &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize an object that has a deserialize(io) static member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">T</td><td>the type of the object to be deserialized. Must have a serialize member function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an io context. </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the object for overload resolution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the restored object if succesful, an error otherwise. </dd></dl>

</div>
</div>
<a id="abffc4606a640125fdd72e78127ad0394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffc4606a640125fdd72e78127ad0394">&#9670;&nbsp;</a></span>deserialize_internal() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class Tup , class  = std::enable_if_t&lt;is_expression_valid&lt;details::tuple_size_value_t, Tup&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;Tup&gt; epi::deserialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; Tup &gt;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deserialize a tuple-like object, e.g. </p>
<p>std::tuple or std::pair. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">Tup</td><td>the tuple-like type to be deserialized, i.e. anything that supports tuple_size and tuple_element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">tag</td><td>define the type of the object to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a restored tuple </dd></dl>

</div>
</div>
<a id="ad40986136d1fe79d33178f311cbf9e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40986136d1fe79d33178f311cbf9e68">&#9670;&nbsp;</a></span>deserialize_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;T&gt; epi::deserialize_json </td>
          <td>(</td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>js</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an object from json. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of value to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">js</td><td>the json value. </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the object for overload resolution. </td></tr>
    <tr><td class="paramname">flags</td><td>define behavior of serialization; see <a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724" title="flags to determine the behavior of the serialization process.">epi::IOFlags</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the deserialized object if succesful, error code otherwise. </dd></dl>

</div>
</div>
<a id="aa6aa17aa8f8a27498436cde19967d84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6aa17aa8f8a27498436cde19967d84e">&#9670;&nbsp;</a></span>draw_sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::draw_sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws a sample from <a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> parameter distributions and stores sample values as <a class="el" href="classepi_1_1SecirParams.html" title="Parameters of an age-resolved SECIR/SECIHURD model.">SecirParams</a> parameter values (cf. </p>
<p><a class="el" href="classepi_1_1UncertainValue.html" title="The UncertainValue class consists of a scalar value and a Distribution object.">UncertainValue</a> and <a class="el" href="classepi_1_1SecirParams.html" title="Parameters of an age-resolved SECIR/SECIHURD model.">SecirParams</a> classes) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">model</td><td><a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> including contact patterns for alle age groups </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a629645f6258a89bbdd5111b36a2f1680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629645f6258a89bbdd5111b36a2f1680">&#9670;&nbsp;</a></span>draw_sample_demographics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::draw_sample_demographics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>draws a sample from the specified distributions for all parameters related to the demographics, e.g. </p>
<p>population. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">model</td><td><a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> including contact patterns for alle age groups </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa47365e82d9077f65082ade2212f6b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47365e82d9077f65082ade2212f6b12">&#9670;&nbsp;</a></span>draw_sample_infection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::draw_sample_infection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>draws a sample from the specified distributions for all parameters related to the infection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">model</td><td><a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> including contact patterns for alle age groups </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43a4d63b899e0bfed36d1f7662a8880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a4d63b899e0bfed36d1f7662a8880e">&#9670;&nbsp;</a></span>dynamic_unique_ptr_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;U&gt; epi::dynamic_unique_ptr_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>base_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a unique_ptr&lt;T&gt; to unique_ptr<u>. </u></p>
<p>behavior is similar to normal dynamic_cast except if the conversion is successful, the original unique_ptr&lt;T&gt; is now in a moved-from state and ownership of the object has been transferred to the returned unique_ptr<u>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_ptr</td><td>ptr to object to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted unique_ptr if object can be cast to U, default unique_ptr otherwise </dd></dl>
<p></u></p>

</div>
</div>
<a id="af935aa9e27620794604cfea702b7be18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af935aa9e27620794604cfea702b7be18">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;::value, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, true&gt; &gt; epi::end </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a const end iterator for the matrix m. </p>

</div>
</div>
<a id="af7f5832acbbcd0a4623c594a42b46090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f5832acbbcd0a4623c594a42b46090">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceepi.html#a9deae6f690facc4fe4d3d3641c1f0458">conjunction_v</a>&lt;std::is_base_of&lt;Eigen::EigenBase&lt;M&gt;, M&gt;, <a class="el" href="namespaceepi_1_1details.html#addd30df2f588966f391bf5a9f25e3418">details::IsElementReference</a>&lt;M&gt; &gt;, <a class="el" href="classepi_1_1RowMajorIterator.html">RowMajorIterator</a>&lt;M, false&gt; &gt; epi::end </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a non-const end iterator for the matrix m. </p>

</div>
</div>
<a id="ab5773aad4934841325a3bc52203919ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5773aad4934841325a3bc52203919ce">&#9670;&nbsp;</a></span>ensemble_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt; epi::ensemble_mean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes mean of each compartment, node, and time point over all runs input must be uniform as returned by interpolated_ensemble_result: same number of nodes, same time points and elements. </p>
<dl class="section see"><dt>See also</dt><dd>interpolated_ensemble_result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble_results</td><td>uniform results of multiple simulation runs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mean of the results over all runs </dd></dl>

</div>
</div>
<a id="a63265d6480ad7cc9f18beedbd0c2bd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63265d6480ad7cc9f18beedbd0c2bd99">&#9670;&nbsp;</a></span>ensemble_params_percentile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Model&gt; epi::ensemble_params_percentile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Model &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the p percentile of the parameters for each node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble_result</td><td>graph of multiple simulation runs </td></tr>
    <tr><td class="paramname">p</td><td>percentile value in open interval (0, 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>p percentile of the parameters over all runs </dd></dl>

</div>
</div>
<a id="a151df8ac841d0287fa4e9b69b35a56a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151df8ac841d0287fa4e9b69b35a56a8">&#9670;&nbsp;</a></span>ensemble_percentile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt; epi::ensemble_percentile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the p percentile of the result for each compartment, node, and time point. </p>
<p>Produces for each compartment the value that that is bigger than approximately a p-th share of the values of this compartment over all runs. input must be uniform as returned by interpolated_ensemble_result: same number of nodes, same time points and elements. </p><dl class="section see"><dt>See also</dt><dd>interpolated_ensemble_result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble_result</td><td>uniform results of multiple simulation runs </td></tr>
    <tr><td class="paramname">p</td><td>percentile value in open interval (0, 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>p percentile of the results over all runs </dd></dl>

</div>
</div>
<a id="aa7330126f86af0488787e500c530d4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7330126f86af0488787e500c530d4eb">&#9670;&nbsp;</a></span>evolve_model()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::evolve_model </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge functor for migration simulation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classepi_1_1SimulationNode.html#aaa7b0b0664650e019242f8d910454a7b">SimulationNode::evolve</a> </dd></dl>

</div>
</div>
<a id="af3d264a78cf80d2626467ca1667ffd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d264a78cf80d2626467ca1667ffd60">&#9670;&nbsp;</a></span>extrapolate_rki_results()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;void&gt; epi::extrapolate_rki_results </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Model &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>results_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factor_inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaling_factor_icu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_days</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets populations data from RKI into a <a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>vector of objects in which the data is set </td></tr>
    <tr><td class="paramname">data_dir</td><td>Path to RKI files </td></tr>
    <tr><td class="paramname">results_dir</td><td>Path to result files </td></tr>
    <tr><td class="paramname">id_name</td><td>Name of region key column </td></tr>
    <tr><td class="paramname">region</td><td>vector of keys of the region of interest </td></tr>
    <tr><td class="paramname">year</td><td>Specifies year at which the data is read </td></tr>
    <tr><td class="paramname">month</td><td>Specifies month at which the data is read </td></tr>
    <tr><td class="paramname">day</td><td>Specifies day at which the data is read </td></tr>
    <tr><td class="paramname">scaling_factor_inf</td><td>factors by which to scale the confirmed cases of rki data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea56b39210ff5804ca2e9f70c4803859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea56b39210ff5804ca2e9f70c4803859">&#9670;&nbsp;</a></span>failure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto epi::failure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1IOStatus.html">IOStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object that is implicitly convertible to an error IOResult&lt;T&gt;. </p>
<p>Use <code>return failure(s)</code> to conveniently return an error from a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the status that contains the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98bd1217065c2bc450f95d7ed82c6e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bd1217065c2bc450f95d7ed82c6e20">&#9670;&nbsp;</a></span>failure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto epi::failure </td>
          <td>(</td>
          <td class="paramtype">std::error_code&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object that is implicitly convertible to an error IOResult&lt;T&gt;. </p>
<p>Use <code>return failure(c, msg)</code> to conveniently return an error from a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>an error code. </td></tr>
    <tr><td class="paramname">msg</td><td>a string that contains more information about the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0a4631ea790b11ade8145033400152b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a4631ea790b11ade8145033400152b">&#9670;&nbsp;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool epi::file_exists </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>rel_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>abs_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7759228642eb55b650e9be3bc77588a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7759228642eb55b650e9be3bc77588a4">&#9670;&nbsp;</a></span>find_value_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TS , class FP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(std::declval&lt;TS&gt;().rend()) epi::find_value_reverse </td>
          <td>(</td>
          <td class="paramtype">TS &amp;&amp;&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FP&#160;</td>
          <td class="paramname"><em>t_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FP&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FP&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the value in the time series at time t_search starting from the end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td><a class="el" href="classepi_1_1TimeSeries.html" title="stores vectors of values at time points (or some other abstract variable) the value at each time poin...">TimeSeries</a> to seach </td></tr>
    <tr><td class="paramname">t_search</td><td>a time point </td></tr>
    <tr><td class="paramname">abs_tol</td><td>absolute floating point tolerance for equality of time values </td></tr>
    <tr><td class="paramname">rel_tol</td><td>relative floating point tolerance for equality of time values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classepi_1_1TimeSeries.html#a65a69f7fdd3dd96db658726d84cfb9ba">TimeSeries::reverse_iterator</a> that points to ts[t_search] or ts.rend() </dd></dl>

</div>
</div>
<a id="ad42a7f19595695226bfc43b114ce45a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42a7f19595695226bfc43b114ce45a9">&#9670;&nbsp;</a></span>flatten_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MultiIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t epi::flatten_index </td>
          <td>(</td>
          <td class="paramtype">MultiIndex const &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiIndex const &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flatten_index takes a set of indices into a mutlidemsional array and calculates the flat index </p>
<p>Given indices (i,j,k,...) of a tensor with dimensions (n,m,l,...), flatten_index calculates the index of the corresponding element if the elements are sorted sequentially in a row major fashion (that is right indices are incremented before left indices)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>a vector of indices of a hypothetical tensor </td></tr>
    <tr><td class="paramname">dimensions</td><td>a vector of the dimension sizes of each dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding flat index </dd></dl>

</div>
</div>
<a id="a4f731d1062d32349437a6a6a8f609576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f731d1062d32349437a6a6a8f609576">&#9670;&nbsp;</a></span>floating_point_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool epi::floating_point_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values for equality with tolerances. </p>
<p>Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Otherwise use relative tolerance. If unsure, use both. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is within the specified relative OR absolute tolerance of v2 <br  />
 </dd></dl>

</div>
</div>
<a id="aeedd090715640a8adc75a509d28b68ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedd090715640a8adc75a509d28b68ba">&#9670;&nbsp;</a></span>floating_point_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool epi::floating_point_greater </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values with tolerances. </p>
<p>v1 &gt; v2 if a) v1 not == v2 within tolerances AND b) v1 not &lt; v2. Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Use relative tolerance (or both) otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is greater than v2 and not within absolute or relative tolerance of v2. </dd></dl>

</div>
</div>
<a id="ad28f87b1b1b5c3170b6e5c91efd835bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28f87b1b1b5c3170b6e5c91efd835bd">&#9670;&nbsp;</a></span>floating_point_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool epi::floating_point_greater_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values with tolerances. </p>
<p>v1 &gt;= v2 if a) v1 &gt; v2 OR b) v1 == v2 within tolerances. Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Use relative tolerance (or both) otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is greater than v2 or within absolute or relative tolerance of v2. </dd></dl>

</div>
</div>
<a id="a5218181b2f8fed7b6cc322bbf0b49d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5218181b2f8fed7b6cc322bbf0b49d12">&#9670;&nbsp;</a></span>floating_point_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool epi::floating_point_less </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values with tolerances. </p>
<p>v1 &lt; v2 if a) v1 not == v2 within tolerances and b) v1 not &gt; v2. Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Use relative tolerance (or both) otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference for equality, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference for equality, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is less than v2 and not within relative or absolute tolerance of v2. </dd></dl>

</div>
</div>
<a id="a9644e0776f61a278b78d8fb7d1d0bc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9644e0776f61a278b78d8fb7d1d0bc7e">&#9670;&nbsp;</a></span>floating_point_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool epi::floating_point_less_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>std::numeric_limits&lt;T&gt;::min()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare two floating point values with tolerances. </p>
<p>v1 &lt;= v2 if a) v1 &lt; v2 OR b) v1 == v2 within tolerances. Use absolute tolerance for comparisons with zero or if you know the magnitude of the values. Use relative tolerance (or both) otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>first floating point value </td></tr>
    <tr><td class="paramname">v2</td><td>second floating point value </td></tr>
    <tr><td class="paramname">abs_tol</td><td>maximum allowed absolute difference, default 0. </td></tr>
    <tr><td class="paramname">rel_tol</td><td>maximum allowed relative difference, default numeric_limits::min. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 is less than v2 or within relative or absolute tolerances of v2. </dd></dl>

</div>
</div>
<a id="a337790a4a6a135a145d173fd7539ad98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337790a4a6a135a145d173fd7539ad98">&#9670;&nbsp;</a></span>foreach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Tags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call f(p, t) for all parameters in a <a class="el" href="classepi_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> with p the value of the parameter t a default constructed parameter tag </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The function type of f </td></tr>
    <tr><td class="paramname">Tags</td><td>the parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the <a class="el" href="classepi_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> </td></tr>
    <tr><td class="paramname">f</td><td>The function to be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaf60f98246e8bc423e8523e05f36617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf60f98246e8bc423e8523e05f36617">&#9670;&nbsp;</a></span>foreach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Tags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1ParameterSet.html">ParameterSet</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30a9d55aaa29669f5e5d465bc3d40e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a9d55aaa29669f5e5d465bc3d40e6a">&#9670;&nbsp;</a></span>foreach_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Params , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::foreach_tag </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call f(t) for all parameters in a <a class="el" href="classepi_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> with t a default constructed parameter tag </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Params</td><td>a <a class="el" href="classepi_1_1ParameterSet.html" title="a set of parameters defined at compile time">ParameterSet</a> </td></tr>
    <tr><td class="paramname">F</td><td>The function type of f </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fbc2ed7c5465ea9c2cfb9fac3b13520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbc2ed7c5465ea9c2cfb9fac3b13520">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::tuple_element&lt; I, std::tuple&lt; <a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags &gt;... &gt; &gt;::type &amp; epi::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27ea5b3eb337484365b27f41df6b7f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ea5b3eb337484365b27f41df6b7f69">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classepi_1_1Index.html">Index</a>&lt; <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a> &gt; &amp; epi::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada4fbb799074a4cc04ea8a0babeacf15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4fbb799074a4cc04ea8a0babeacf15">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::tuple_element&lt; I, std::tuple&lt; <a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags &gt;... &gt; &gt;::type const  &amp; epi::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab311b8323aa23aea0da2bf70b01891b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab311b8323aa23aea0da2bf70b01891b2">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename... CategoryTags, std::enable_if_t&lt;(sizeof...(CategoryTags) &gt; 1), void &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classepi_1_1Index.html">Index</a>&lt; <a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a> &gt; const  &amp; epi::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1Index.html">Index</a>&lt; CategoryTags... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a279b902eaea75789d1cb3e6fb4fc88b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279b902eaea75789d1cb3e6fb4fc88b3">&#9670;&nbsp;</a></span>get_active_damping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingExpr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Ref&lt;const typename DampingExpr::Matrix&gt; epi::get_active_damping </td>
          <td>(</td>
          <td class="paramtype">const DampingExpr &amp;&#160;</td>
          <td class="paramname"><em>damping_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingLevel&#160;</td>
          <td class="paramname"><em>lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of the damping that matches the given type and level and that is active at the specified time. </p>
<p>If no damping is found, returns a zero matrix of the correct shape. Utility for implementation of dynamic NPIs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damping_expr</td><td>some matrix expression that contains dampings, e.g. a <a class="el" href="classepi_1_1ContactMatrix.html" title="represents time dependent contact frequencies between groups.">ContactMatrix</a>. </td></tr>
    <tr><td class="paramname">lvl</td><td>damping level to match </td></tr>
    <tr><td class="paramname">type</td><td>damping type to match </td></tr>
    <tr><td class="paramname">time</td><td>time where the damping is active </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matrix of damping coefficients if active damping is found. zero matrix otherwise. </dd></dl>

</div>
</div>
<a id="a57b95cd167f5b05ea85d763da3ae8002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b95cd167f5b05ea85d763da3ae8002">&#9670;&nbsp;</a></span>get_county_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; std::vector&lt; int &gt; &gt; epi::get_county_ids </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a vector with the ids of all german counties </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>directory to population data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a84705a311d53bb6f2f15c8e95955bb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84705a311d53bb6f2f15c8e95955bb4c">&#9670;&nbsp;</a></span>get_current_dir_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string epi::get_current_dir_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current working directory name. </p>

</div>
</div>
<a id="a07fe15b03cd80011389629a1d6f5f414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fe15b03cd80011389629a1d6f5f414">&#9670;&nbsp;</a></span>get_damping_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingExpr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; epi::get_damping_indices </td>
          <td>(</td>
          <td class="paramtype">const DampingExpr &amp;&#160;</td>
          <td class="paramname"><em>damping_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingLevel&#160;</td>
          <td class="paramname"><em>lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DampingType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of indices of specified dampings. </p>
<p>Returns the indices of dampings that match the given type and level and that become active in the specified time span (excluding the particular interval boundaries, begin and end). Utility for implementation of dynamic NPIs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damping_expr</td><td>some matrix expression that contains dampings, e.g. a <a class="el" href="classepi_1_1ContactMatrix.html" title="represents time dependent contact frequencies between groups.">ContactMatrix</a>. </td></tr>
    <tr><td class="paramname">lvl</td><td>damping level to match </td></tr>
    <tr><td class="paramname">type</td><td>damping type to match </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the time span that contains the dampings </td></tr>
    <tr><td class="paramname">end</td><td>end of the time span that contains the dampings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of indices in range damping_expr.get_dampings() </dd></dl>

</div>
</div>
<a id="ab806a15579c38196fd438b6de9064e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab806a15579c38196fd438b6de9064e86">&#9670;&nbsp;</a></span>get_day_in_year()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int epi::get_day_in_year </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the day in year based on a given date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>date </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>day in year, starting January, 1st, with 1. </dd></dl>

</div>
</div>
<a id="aaedbe2736f98abcbddbb5030bc1c36f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedbe2736f98abcbddbb5030bc1c36f8">&#9670;&nbsp;</a></span>get_infections_relative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Base  = Simulation&lt;SecirModel&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double epi::get_infections_relative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1SecirSimulation.html">SecirSimulation</a>&lt; Base &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get percentage of infections per total population. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>the compartment model with initial values. </td></tr>
    <tr><td class="paramname">t</td><td>current simulation time. </td></tr>
    <tr><td class="paramname">y</td><td>current value of compartments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>simulation type that uses a secir compartment model. see <a class="el" href="classepi_1_1SecirSimulation.html" title="specialization of compartment model simulation for secir models.">SecirSimulation</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5aaa132a35ad0befebd665dac41fa7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5aaa132a35ad0befebd665dac41fa7b">&#9670;&nbsp;</a></span>get_infections_relative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; get_infections_relative_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double epi::get_infections_relative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the percantage of infected people of the total population in the node If dynamic NPIs are enabled, there needs to be an overload of get_infections_relative(model, y) for the Model type that can be found with argument-dependent lookup. </p>
<p>Ideally define get_infections_relative in the same namespace as the Model type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a node of a migration graph. </td></tr>
    <tr><td class="paramname">y</td><td>the current value of the simulation. </td></tr>
    <tr><td class="paramname">t</td><td>the current simulation time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26c36a5ce9b2e07290a30ab659cc7ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c36a5ce9b2e07290a30ab659cc7ae8">&#9670;&nbsp;</a></span>get_migration_factors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Base  = Simulation&lt;SecirModel&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::get_migration_factors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1SecirSimulation.html">SecirSimulation</a>&lt; Base &gt; &amp;&#160;</td>
          <td class="paramname"><em>sim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get migration factors. </p>
<p>Used by migration graph simulation. Like infection risk, migration of infected individuals is reduced if they are well isolated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>the compartment model with initial values. </td></tr>
    <tr><td class="paramname">t</td><td>current simulation time. </td></tr>
    <tr><td class="paramname">y</td><td>current value of compartments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector expression, same size as y, with migration factors per compartment. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>simulation type that uses a secir compartment model. see <a class="el" href="classepi_1_1SecirSimulation.html" title="specialization of compartment model simulation for secir models.">SecirSimulation</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175a57f9e3ae1cb3286ee8fa12382b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175a57f9e3ae1cb3286ee8fa12382b21">&#9670;&nbsp;</a></span>get_migration_factors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim , std::enable_if_t&lt;!is_expression_valid&lt; get_migration_factors_expr_t, Sim &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::get_migration_factors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an additional migration factor. </p>
<p>The absolute migration for each compartment is computed by c_i * y_i * f_i, wher c_i is the coefficient set in <a class="el" href="classepi_1_1MigrationParameters.html" title="parameters that influence migration.">MigrationParameters</a>, y_i is the current compartment population, f_i is the factor returned by this function. This factor is optional, default 1.0. If you need to adjust migration in that way, overload get_migration_factors(model, t, y) for your Model type so that can be found with argument-dependent lookup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a node of a migration graph. </td></tr>
    <tr><td class="paramname">y</td><td>the current value of the simulation. </td></tr>
    <tr><td class="paramname">t</td><td>the current simulation time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector expression, same size as y, with the factor for each compartment. </dd></dl>

</div>
</div>
<a id="a86bc0438a59f5c4b94f7c7b5897f478c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bc0438a59f5c4b94f7c7b5897f478c">&#9670;&nbsp;</a></span>get_offset_in_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int epi::get_offset_in_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the offset in days given two dates: first date minus second date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date1</td><td>first date. </td></tr>
    <tr><td class="paramname">date2</td><td>second date. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset in days between the two dates. </dd></dl>

</div>
</div>
<a id="a2a8006d3f83c79255c00f516642af4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8006d3f83c79255c00f516642af4bc">&#9670;&nbsp;</a></span>go_to_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> epi::go_to_event </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Person.html">Person</a> &amp;&#160;</td>
          <td class="paramname"><em>person</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>people go to social events outside work/school. </p>

</div>
</div>
<a id="a2c053690bddcfe7cee8faa45690dc58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c053690bddcfe7cee8faa45690dc58a">&#9670;&nbsp;</a></span>go_to_hospital()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> epi::go_to_hospital </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Person.html">Person</a> &amp;&#160;</td>
          <td class="paramname"><em>person</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>infected people may be hospitalized. </p>

</div>
</div>
<a id="a1ec5b9e2e918900a0a79c87ebd2c2715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec5b9e2e918900a0a79c87ebd2c2715">&#9670;&nbsp;</a></span>go_to_icu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> epi::go_to_icu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Person.html">Person</a> &amp;&#160;</td>
          <td class="paramname"><em>person</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>people in the hospital may be put in intensive care. </p>

</div>
</div>
<a id="a9ff16386da2103676b52c1d584475aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff16386da2103676b52c1d584475aa7">&#9670;&nbsp;</a></span>go_to_school()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> epi::go_to_school </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Person.html">Person</a> &amp;&#160;</td>
          <td class="paramname"><em>person</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>school age children go to school in the morning and return later in the day. </p>

</div>
</div>
<a id="a970fc0a5ff7521fa430bf0cb304aa226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970fc0a5ff7521fa430bf0cb304aa226">&#9670;&nbsp;</a></span>go_to_shop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> epi::go_to_shop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Person.html">Person</a> &amp;&#160;</td>
          <td class="paramname"><em>person</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>people go to the shop outside work/school except on sunday. </p>

</div>
</div>
<a id="a8bedb153040a57179bff647438f7a715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bedb153040a57179bff647438f7a715">&#9670;&nbsp;</a></span>go_to_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> epi::go_to_work </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Person.html">Person</a> &amp;&#160;</td>
          <td class="paramname"><em>person</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>working age adults go to work in the morning and return later in the day. </p>

</div>
</div>
<a id="a8439865d7d71fb2382b3b2785aed2753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8439865d7d71fb2382b3b2785aed2753">&#9670;&nbsp;</a></span>hours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a> epi::hours </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hours</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a <a class="el" href="classepi_1_1TimeSpan.html" title="a duration of time.">TimeSpan</a> of a specified number of hours. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>number of hours in the time span. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa64417a4719c5d1b6d0d7092a91ffe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa64417a4719c5d1b6d0d7092a91ffe5">&#9670;&nbsp;</a></span>implement_dynamic_npis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingExprGroup , class MakeMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::implement_dynamic_npis </td>
          <td>(</td>
          <td class="paramtype">DampingExprGroup &amp;&#160;</td>
          <td class="paramname"><em>damping_expr_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classepi_1_1DampingSampling.html">DampingSampling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>npis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SimulationTime.html">SimulationTime</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MakeMatrix &amp;&amp;&#160;</td>
          <td class="paramname"><em>make_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implement dynamic NPIs for a time span. </p>
<p>Adds or removes dampings to ensure that the active dampings during the specified time span is at least as big as the specified dynamic dampings. If another damping of the same type and level is active at the beginning of the time span or becomes active during the time span, the coefficient wise maximum of the new damping and the existing damping is used. At the end of the time span, another set of dampings may be added that restores the dampings on each level and type as they would have been without the dynamic npis that have just been implemented. Examples: a) no damping exists yet, dynamic npi of value <code>d</code>: one damping is added at the beginning of the time span that has the value <code>d</code>, another damping is added at the end of the time span that has a value zero. b) damping of value <code>a</code> is active before the beginning of the time span, dynamic npi of value <code>d</code> is added: one damping is added at the beginning of the time span that has the value <code>max(a, d)</code>, another damping is added at the end of the time span that has the value a b) damping of value <code>a</code> becomes active at a time <code>t_a</code> between the beginning of the time span and the end, dynamic npi of value <code>d</code> is added: one damping is added at the beginning of the time span that has the value <code>d</code>, the value of the damping at time <code>t_a</code> is set to <code>max(d, a)</code>, another damping is added at the end of the time span that has the value a </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damping_expr_group</td><td>a group of matrix expressions that contains dampings, e.g. a <a class="el" href="classepi_1_1ContactMatrixGroup.html" title="represents a collection of contact frequency matrices that whose sum is the total number of contacts.">ContactMatrixGroup</a>. </td></tr>
    <tr><td class="paramname">dynamic_npis</td><td>the NPIs to be implemented </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of the time span that the NPIs will be active for. </td></tr>
    <tr><td class="paramname">end</td><td>end of the time span that the NPIs will be active for. </td></tr>
    <tr><td class="paramname">make_matrix</td><td>function to make a matrix of the same shape as the damping expression, see e.g. make_contact_damping_matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cb9e6904c93b4dc7834448dd98e59a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb9e6904c93b4dc7834448dd98e59a6">&#9670;&nbsp;</a></span>insert_sorted_replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt;::iterator epi::insert_sorted_replace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9392c02c0e21e76d64e16bce3b198dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9392c02c0e21e76d64e16bce3b198dff">&#9670;&nbsp;</a></span>insert_sorted_replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt;::iterator epi::insert_sorted_replace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts element in a sorted vector, replacing items that are equal precondition: elements in the vector are partially sorted and unique according the predicate postcondition: same as precondition, additionally contains exactly one element that is equal to item, order of other items is preserved </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector where item will be inserted </td></tr>
    <tr><td class="paramname">item</td><td>item to insert </td></tr>
    <tr><td class="paramname">pred</td><td>binary comparator, pred(item, a) returns true if item should go before element a, pred(a, item) returns true if element a should go before item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to inserted or replaced item in vec </dd></dl>

</div>
</div>
<a id="a2b02b1dc709b5f9253f71ec29d17e862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b02b1dc709b5f9253f71ec29d17e862">&#9670;&nbsp;</a></span>interpolate_ensemble_results()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceepi.html#aec4b1dbb8f2d81b0e5af433760fc156c">InterpolateResultT</a>&lt;T&gt; &gt; epi::interpolate_ensemble_results </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates results of all runs with evenly spaced, integer time points. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceepi.html#a9dfb5f0f7703e75e9667ff4bedcf5e97" title="TODO: extrapolate first and last point.">interpolate_simulation_result</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble_result</td><td>result of multiple simulations (single <a class="el" href="classepi_1_1TimeSeries.html" title="stores vectors of values at time points (or some other abstract variable) the value at each time poin...">TimeSeries</a> or <a class="el" href="classepi_1_1Graph.html" title="generic graph structure">Graph</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated time series, one (or as many as nodes in the graph) per result in the ensemble </dd></dl>

</div>
</div>
<a id="ac1d23ba06a863a2a3fbed1a851774ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d23ba06a863a2a3fbed1a851774ddf">&#9670;&nbsp;</a></span>interpolate_simulation_result() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Simulation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt;double&gt; &gt; epi::interpolate_simulation_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Graph.html">Graph</a>&lt; <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; <a class="el" href="classepi_1_1Simulation.html">Simulation</a> &gt;, <a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interpolate time series with evenly spaced, integer time points for each node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceepi.html#a9dfb5f0f7703e75e9667ff4bedcf5e97" title="TODO: extrapolate first and last point.">interpolate_simulation_result</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph_result</td><td>graph of simulations whose results will be interpolated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one interpolated time series per node </dd></dl>

</div>
</div>
<a id="a9dfb5f0f7703e75e9667ff4bedcf5e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfb5f0f7703e75e9667ff4bedcf5e97">&#9670;&nbsp;</a></span>interpolate_simulation_result() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; epi::interpolate_simulation_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>simulation_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: extrapolate first and last point. </p>
<p>interpolate time series with evenly spaced, integer time points.</p>
<p>time points [t0, t1, t2, ..., tmax] interpolated as [floor(t0), floor(t0) + 1,...,ceil(tmax)]. values at new time points are linearly interpolated from their immediate neighbors from the old time points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simulation_result</td><td>time series to interpolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated time series </dd></dl>

</div>
</div>
<a id="aea7efd28c38b8396b5e973ef50651f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7efd28c38b8396b5e973ef50651f91">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9fd2a4b9b1aa2015f4e81d325579012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fd2a4b9b1aa2015f4e81d325579012">&#9670;&nbsp;</a></span>log_debug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::log_debug </td>
          <td>(</td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af340c99e598304426b460ebb1b8337ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af340c99e598304426b460ebb1b8337ea">&#9670;&nbsp;</a></span>log_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::log_error </td>
          <td>(</td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad02ac4b2145bcd08b1106c26df127a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02ac4b2145bcd08b1106c26df127a2f">&#9670;&nbsp;</a></span>log_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::log_info </td>
          <td>(</td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2d87d1c357272a7bd0879c96c3920ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d87d1c357272a7bd0879c96c3920ae">&#9670;&nbsp;</a></span>log_rng_seeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::log_rng_seeds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1RandomNumberGenerator.html">RandomNumberGenerator</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43e96e0c7cf69c7e79851b152319e09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e96e0c7cf69c7e79851b152319e09e">&#9670;&nbsp;</a></span>log_thread_local_rng_seeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::log_thread_local_rng_seeds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d95c3ae27c7d000e7ec3efe67efe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d95c3ae27c7d000e7ec3efe67efe3a">&#9670;&nbsp;</a></span>log_warning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::log_warning </td>
          <td>(</td>
          <td class="paramtype">spdlog::string_view_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abea3dfd561fb443543ac1543014f53fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea3dfd561fb443543ac1543014f53fc">&#9670;&nbsp;</a></span>major_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index epi::major_size </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of rows (columns) of a row (column) major matrix. </p>

</div>
</div>
<a id="ab60af54eb89d33078a22ba5a5f1c89fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60af54eb89d33078a22ba5a5f1c89fa">&#9670;&nbsp;</a></span>make_contact_damping_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::make_contact_damping_matrix </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>groups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a contact damping matrix from dampings by group. </p>
<p>Maps a vector of dampings by group onto a contact damping matrix according to the formula d_ij = 1 - sqrt((1 - g_i) * (1 - g_j)) where d_ij is a coefficient of the matrix and g_i,g_j are coefficients of the group vector. For diagonal elements (i.e. contacts of group with itself): d_ii = g_i; the damping of the corresponding group is applied directly. For off diagonal elements (i.e. contacts of group with other group): d_ij between g_i and g_j; the dampings of both groups are combined and applied equally. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>damping value weighted by group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>square matrix expression of damping coefficients. </dd></dl>

</div>
</div>
<a id="a040956ca8ae80e87a860d2202981eb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040956ca8ae80e87a860d2202981eb86">&#9670;&nbsp;</a></span>make_error_code() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::error_code&amp; epi::make_error_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1IOStatus.html">IOStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a> to std::error_code. </p>
<p>Expected customization point of std::error_code. </p>

</div>
</div>
<a id="ab983c9da111a8501867c8320c9c4c908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab983c9da111a8501867c8320c9c4c908">&#9670;&nbsp;</a></span>make_error_code() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code epi::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#a1e26c2aefb564c12224c2dd16b1ba8ce">StatusCode</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert StatusCode to std::error_code. </p>
<p>Expected customization point of std::error_code. </p>

</div>
</div>
<a id="a44f13a4d8ef4051c7bdedcfb2b4152c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f13a4d8ef4051c7bdedcfb2b4152c3">&#9670;&nbsp;</a></span>make_graph_sim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph , class NodeF , class EdgeF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::make_graph_sim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1Graph.html">Graph</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeF &amp;&amp;&#160;</td>
          <td class="paramname"><em>node_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeF &amp;&amp;&#160;</td>
          <td class="paramname"><em>edge_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0425e3efce900644c00db5db5c6f33d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0425e3efce900644c00db5db5c6f33d4">&#9670;&nbsp;</a></span>make_migration_damping_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::make_migration_damping_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1ColumnVectorShape.html">ColumnVectorShape</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make migration coefficient damping vector from dampings by group. </p>
<p>Maps the vector of dampings by group onto a migration coefficient damping vector [g_0, g_0, ..., g_1, g_1, ..., g_2, ...]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape (i.e. size) of the migration coefficient vector. </td></tr>
    <tr><td class="paramname">groups</td><td>damping value weighted by group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector expression of migration coefficient damping. </dd></dl>

</div>
</div>
<a id="ad7a9ce8ee1301d3029dfab2a1638c2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a9ce8ee1301d3029dfab2a1638c2a0">&#9670;&nbsp;</a></span>make_migration_sim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1GraphSimulation.html">GraphSimulation</a>&lt;<a class="el" href="classepi_1_1Graph.html">Graph</a>&lt;<a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt;Sim&gt;, <a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a>&gt; &gt; epi::make_migration_sim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Graph.html">Graph</a>&lt; <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a migration simulation. </p>
<p>After every second time step, for each edge a portion of the population corresponding to the coefficients of the edge moves from one node to the other. In the next timestep, the migrated population return to their "home" node. Returns are adjusted based on the development in the target node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>start time of the simulation </td></tr>
    <tr><td class="paramname">dt</td><td>time step between migrations </td></tr>
    <tr><td class="paramname">graph</td><td>set up for migration simulation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7204c5aaf636eb8a55aa32d350e6c6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7204c5aaf636eb8a55aa32d350e6c6ef">&#9670;&nbsp;</a></span>make_migration_sim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1GraphSimulation.html">GraphSimulation</a>&lt;<a class="el" href="classepi_1_1Graph.html">Graph</a>&lt;<a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt;Sim&gt;, <a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a>&gt; &gt; epi::make_migration_sim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1Graph.html">Graph</a>&lt; <a class="el" href="classepi_1_1SimulationNode.html">SimulationNode</a>&lt; Sim &gt;, <a class="el" href="classepi_1_1MigrationEdge.html">MigrationEdge</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96d5e8ca704a28fff2d40c32a548e921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d5e8ca704a28fff2d40c32a548e921">&#9670;&nbsp;</a></span>make_observer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1observer__ptr.html">observer_ptr</a>&lt;T&gt; epi::make_observer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a647bf8579337d11164eec7bcc3b2f3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647bf8579337d11164eec7bcc3b2f3f8">&#9670;&nbsp;</a></span>make_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter1 , class Iter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::make_range </td>
          <td>(</td>
          <td class="paramtype">Iter1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c7062f556f01dc09259d600017a3cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7062f556f01dc09259d600017a3cd1">&#9670;&nbsp;</a></span>make_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterPair &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::make_range </td>
          <td>(</td>
          <td class="paramtype">IterPair &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>factories for template argument deduction </p>

</div>
</div>
<a id="a581ff5aecdf59ce593360a1b53457cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581ff5aecdf59ce593360a1b53457cb1">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rng , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::map </td>
          <td>(</td>
          <td class="paramtype">const Rng &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a random access range (i.e. </p>
<p>anything with size() and operator[], e.g. std::vector) onto a Eigen array expression. Returns a column array expression ´a´ where a[i] = f(v[i]). The returned expression stores a reference to the range, lifetime of the range must exceed lifetime of the return. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a random access range. </td></tr>
    <tr><td class="paramname">f</td><td>a function that returns a numeric scalar for each element of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array expression ´a´ the same size as v where a[i] = f(v[i]). </dd></dl>

</div>
</div>
<a id="ad671e5cd3a4ab1b63f066b3b7d4e7e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad671e5cd3a4ab1b63f066b3b7d4e7e2f">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::max </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>coefficient wise maximum of two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a matrix expression </td></tr>
    <tr><td class="paramname">b</td><td>a matrix expression of the same shape as a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix expression the shape of a with each coefficient the maximum of the coefficients of a and b. </dd></dl>

</div>
</div>
<a id="a75f5e455e9258212cdb0e51a1f97a586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f5e455e9258212cdb0e51a1f97a586">&#9670;&nbsp;</a></span>minor_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index epi::minor_size </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of columns (rows) of a row (column) major matrix. </p>

</div>
</div>
<a id="a6e7f2f3c9c94a6990a6bff230b1c7f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7f2f3c9c94a6990a6bff230b1c7f30">&#9670;&nbsp;</a></span>offset_date_by_days()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structepi_1_1Date.html">Date</a> epi::offset_date_by_days </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_days</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the new date corresponding to a given date and a offset in days. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>date. </td></tr>
    <tr><td class="paramname">offset_days</td><td>offset in days. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new date that is date + offset_days. </dd></dl>

</div>
</div>
<a id="a6e85ce3d223aad59b2dc369e3eb0d28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e85ce3d223aad59b2dc369e3eb0d28c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a>&lt;T&gt;::value, bool&gt; epi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade052ae39516a7c1232ad35ffcc281d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade052ae39516a7c1232ad35ffcc281d8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a>&lt;T&gt;::value, bool&gt; epi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae47b1f4d8dcf4e73189d1d7bc52266ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47b1f4d8dcf4e73189d1d7bc52266ec">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a>&lt;T&gt;::value, std::ostream&amp;&gt; epi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>out stream operator for edges if edge property type has stream operator defined </p>

</div>
</div>
<a id="afa66fe98b87799627f7a73c780a11331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa66fe98b87799627f7a73c780a11331">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a>&lt;T&gt;::value, std::ostream&amp;&gt; epi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>out stream operator for edges if edge property type does not have stream operator defined </p>

</div>
</div>
<a id="a8f154756e9e9cc7cf261b6ee9a725e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f154756e9e9cc7cf261b6ee9a725e9e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a>&lt;T&gt;::value, bool&gt; epi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Edge.html">Edge</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison operator if edge property type is equality comparable </p>

</div>
</div>
<a id="ab61d5abc1807be68b6531c48dbed9516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61d5abc1807be68b6531c48dbed9516">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceepi.html#af568a71f01950c9f9cff23e59571f1ee">has_eq_op</a>&lt;T&gt;::value, bool&gt; epi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structepi_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison operator if node property type is equality comparable </p>

</div>
</div>
<a id="a4f5627edce6ec776893a7a80bfe92c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5627edce6ec776893a7a80bfe92c51">&#9670;&nbsp;</a></span>parse_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structepi_1_1Date.html">Date</a> epi::parse_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>date_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses a date from a string. </p>
<p>uses fixed format YYYY.MM.DD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>date as a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed date. </dd></dl>

</div>
</div>
<a id="a4595ae862d8bd1d17a7acd5bdf9eed75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4595ae862d8bd1d17a7acd5bdf9eed75">&#9670;&nbsp;</a></span>path_join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class String , class... Strings&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string epi::path_join </td>
          <td>(</td>
          <td class="paramtype">String &amp;&amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Strings &amp;&amp;...&#160;</td>
          <td class="paramname"><em>app</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>join one ore more strings with path separators. </p>
<p>Accepts mixed C strings or std::strings.</p>
<p>example: </p><pre class="fragment">std::string hello("Hello");
auto p = path_join(hello, "World"); //returns "Hello/World"
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>first string </td></tr>
    <tr><td class="paramname">app</td><td>zero or more other strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all inputs joined </dd></dl>

</div>
</div>
<a id="a6f87f69b1ceb20f1a2e71c399e3abe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f87f69b1ceb20f1a2e71c399e3abe13">&#9670;&nbsp;</a></span>print_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::print_graph </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a201d7af8010e9eab0c7d951a81c8aeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201d7af8010e9eab0c7d951a81c8aeb7">&#9670;&nbsp;</a></span>print_graph_object() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a>&lt;T&gt;::value, void&gt; epi::print_graph_object </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af736f166eb9e6ca47a130a635562fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af736f166eb9e6ca47a130a635562fb0b">&#9670;&nbsp;</a></span>print_graph_object() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceepi.html#aab571ed7d1014cba00ba92c61dc5a729">has_ostream_op</a>&lt;T&gt;::value, void&gt; epi::print_graph_object </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbce423b42545473a89380554ba0b45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbce423b42545473a89380554ba0b45c">&#9670;&nbsp;</a></span>print_seir_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::print_seir_params </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1SeirModel.html">SeirModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints given parameters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>the SeirParams parameter object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae264f41ee1dab690ef20b8cf9afb0957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae264f41ee1dab690ef20b8cf9afb0957">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1IOStatus.html">IOStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gtest printer for <a class="el" href="classepi_1_1IOStatus.html" title="IOStatus represents the result of an operation.">IOStatus</a>. </p>

</div>
</div>
<a id="a07e0a062523d918b5aa5af93e7c6692b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e0a062523d918b5aa5af93e7c6692b">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1UncertainValue.html">UncertainValue</a> &amp;&#160;</td>
          <td class="paramname"><em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad43bae002ebf92b151b96ab0e7b66321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43bae002ebf92b151b96ab0e7b66321">&#9670;&nbsp;</a></span>random_migration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> epi::random_migration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Person.html">Person</a> &amp;&#160;</td>
          <td class="paramname"><em>person</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>completely random migration to any other location. </p>

</div>
</div>
<a id="a12182cdd3c2108a61069855e9bc9f976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12182cdd3c2108a61069855e9bc9f976">&#9670;&nbsp;</a></span>random_transition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t NumTransitions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T epi::random_transition </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>current_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T, double &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>transitions</em>[NumTransitions]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>select a random transition from a list of possible transitions from the current state to others. </p>
<p>Each transition is represented by the new state and the probability of the transition, e.g. a pair {1, 0.5} is the transition to state 1 with rate 0.5. Transition rates are not probabilities but the parameters of an exponential distribution. One of the transitions happens if x &lt; dt, where x is a sample from the exponential distribution Exp(S), S begin the sum of all rates. Which transition happens is determined by sampling from a discrete distribution with the rates as weights. It's also possible that no transition happens in this time step. In this case the current state is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type that represents the states </td></tr>
    <tr><td class="paramname">NumTransitions</td><td>number of possible transitions </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_state</td><td>current state before transitions </td></tr>
    <tr><td class="paramname">dt</td><td>length of the time step </td></tr>
    <tr><td class="paramname">transitions</td><td>array of pairs of new states and their rates (probabilities) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new state from the list if transition happens, current_state otherwise </dd></dl>

</div>
</div>
<a id="ac70f469d232b6a3b17f9748465a62acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70f469d232b6a3b17f9748465a62acf">&#9670;&nbsp;</a></span>read_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;<a class="el" href="classepi_1_1Graph.html">Graph</a>&lt;Model, <a class="el" href="classepi_1_1MigrationParameters.html">MigrationParameters</a>&gt; &gt; epi::read_graph </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioflags</em> = <code><a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads graph json files and returns a simulation graph. </p>
<p>See write_graph for information of expected files. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>type of the simulation model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>directory from where graph should be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f8939e488603b6fe019d5ba85e0afad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8939e488603b6fe019d5ba85e0afad">&#9670;&nbsp;</a></span>read_json() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;Json::Value&gt; epi::read_json </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a json value from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a json value if succesful, error code otherwise. </dd></dl>

</div>
</div>
<a id="a8d0987b8a2671181957dbbcc612cba11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0987b8a2671181957dbbcc612cba11">&#9670;&nbsp;</a></span>read_json() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;T&gt; epi::read_json </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">Tag</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a json value from a file and deserialize it into an object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of value to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path of the file. </td></tr>
    <tr><td class="paramname">tag</td><td>defines the type of the object for overload resolution. </td></tr>
    <tr><td class="paramname">flags</td><td>define behavior of serialization; see <a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724" title="flags to determine the behavior of the serialization process.">epi::IOFlags</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the deserialized object if succesful, error code otherwise. </dd></dl>

</div>
</div>
<a id="aaf6dd630c672a729aad58836976efb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6dd630c672a729aad58836976efb87">&#9670;&nbsp;</a></span>read_mobility_formatted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; Eigen::MatrixXd &gt; epi::read_mobility_formatted </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads formatted migration or contact data which is given in columns from_str to_str from_rs to_rs count_abs and separated by tabs. </p>
<p>Writes it into a NxN Eigen Matrix, where N is the number of regions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file to be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53d4ad2f5843dc2359c155c733b9295b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d4ad2f5843dc2359c155c733b9295b">&#9670;&nbsp;</a></span>read_mobility_plain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; Eigen::MatrixXd &gt; epi::read_mobility_plain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads txt migration data or contact which is given by values only and separated by spaces. </p>
<p>Writes it into a NxN Eigen Matrix, where N is the number of regions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file to be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95bb05811835f12b6509f65fefb08624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bb05811835f12b6509f65fefb08624">&#9670;&nbsp;</a></span>read_population_data_county()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;void&gt; epi::read_population_data_county </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Model &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>county</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factor_inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaling_factor_icu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads population data from population files for the specefied county </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>vector of model in which the data is set </td></tr>
    <tr><td class="paramname">date</td><td><a class="el" href="structepi_1_1Date.html" title="Simple date representation as year, month, and day.">Date</a> for which the data should be read </td></tr>
    <tr><td class="paramname">county</td><td>vector of region keys of counties of interest </td></tr>
    <tr><td class="paramname">scaling_factor_inf</td><td>factors by which to scale the confirmed cases of rki data </td></tr>
    <tr><td class="paramname">scaling_factor_icu</td><td>factor by which to scale the icu cases of divi data </td></tr>
    <tr><td class="paramname">dir</td><td>directory of files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8a2a738cb0ff1f34dd754502a45665a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a2a738cb0ff1f34dd754502a45665a">&#9670;&nbsp;</a></span>read_population_data_germany()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;void&gt; epi::read_population_data_germany </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Model &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factor_inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaling_factor_icu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads population data from population files for the whole country </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>vector of model in which the data is set </td></tr>
    <tr><td class="paramname">date</td><td><a class="el" href="structepi_1_1Date.html" title="Simple date representation as year, month, and day.">Date</a> for which the data should be read </td></tr>
    <tr><td class="paramname">scaling_factor_inf</td><td>factors by which to scale the confirmed cases of rki data </td></tr>
    <tr><td class="paramname">scaling_factor_icu</td><td>factor by which to scale the icu cases of divi data </td></tr>
    <tr><td class="paramname">dir</td><td>directory of files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a834e31d5aabbe9d0d0d39e429a3b661d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834e31d5aabbe9d0d0d39e429a3b661d">&#9670;&nbsp;</a></span>read_population_data_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;void&gt; epi::read_population_data_state </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Model &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structepi_1_1Date.html">Date</a>&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factor_inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaling_factor_icu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads population data from population files for the specefied state </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>vector of model in which the data is set </td></tr>
    <tr><td class="paramname">date</td><td><a class="el" href="structepi_1_1Date.html" title="Simple date representation as year, month, and day.">Date</a> for which the data should be read </td></tr>
    <tr><td class="paramname">state</td><td>vector of region keys of states of interest </td></tr>
    <tr><td class="paramname">scaling_factor_inf</td><td>factors by which to scale the confirmed cases of rki data </td></tr>
    <tr><td class="paramname">scaling_factor_icu</td><td>factor by which to scale the icu cases of divi data </td></tr>
    <tr><td class="paramname">dir</td><td>directory of files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca4e4c461ef6658ee53825f5490981c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4e4c461ef6658ee53825f5490981c2">&#9670;&nbsp;</a></span>read_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; std::vector&lt; <a class="el" href="classepi_1_1SecirSimulationResult.html">SecirSimulationResult</a> &gt; &gt; epi::read_result </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read secir simulation result from h5 file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file </td></tr>
    <tr><td class="paramname">nb_groups</td><td>number of groups used during simulation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2b36aafc23a8ab1b41f63a8f25b4e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b36aafc23a8ab1b41f63a8f25b4e96">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::reshape </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reshape the matrix. </p>
<p>Total number of entries before and after the reshape must be the same. The new matrix shares memory with the input matrix, no copying is performed, changes to the new matrix will be made to the input matrix as well. Assign to another matrix of compatible size if you need a copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>matrix to reshape </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows of the new matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of cols of the new matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matrix expression with the same entries as the input matrix but new shape </dd></dl>

</div>
</div>
<a id="a61a8a4cdffb9aaeafb0085c369530d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a8a4cdffb9aaeafb0085c369530d3c">&#9670;&nbsp;</a></span>result_distance_2norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double epi::result_distance_2norm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">epi::TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">epi::TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the distance between two SECIR simulation results. </p>
<p>The distance is the 2-norm of the element-wise difference of the two results. The two results (e.g. output of interpolate_simulation_result) must have the same dimensions and number of time points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result1</td><td>first result. </td></tr>
    <tr><td class="paramname">result2</td><td>second result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Computed distance between result1 and result2. </dd></dl>

</div>
</div>
<a id="a7babc0f40c19f04b6847fd1c258fe86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7babc0f40c19f04b6847fd1c258fe86b">&#9670;&nbsp;</a></span>result_distance_2norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double epi::result_distance_2norm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">epi::TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">epi::TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#aa085820f5ddc6774e7591ec0b5305092">InfectionState</a>&#160;</td>
          <td class="paramname"><em>compartment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the distance between two SECIR simulation results in one compartment. </p>
<p>The distance is the 2-norm of the element-wise difference of the two results in the specified compartment. The two results (e.g. output of interpolate_simulation_result) must have the same dimensions and number of time points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result1</td><td>first result. </td></tr>
    <tr><td class="paramname">result2</td><td>second result. </td></tr>
    <tr><td class="paramname">compartment</td><td>the compartment to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Computed distance between result1 and result2. </dd></dl>

</div>
</div>
<a id="a0131fc9550fe8d026137df0b31f358a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0131fc9550fe8d026137df0b31f358a9">&#9670;&nbsp;</a></span>return_home_when_recovered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#adabd8b3f600e98668b14d2d891526943">LocationType</a> epi::return_home_when_recovered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Person.html">Person</a> &amp;&#160;</td>
          <td class="paramname"><em>person</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>people in the hospital/icu return home when they recover. </p>

</div>
</div>
<a id="a5bb73a1a2ab77102ffcff487eda30e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb73a1a2ab77102ffcff487eda30e21">&#9670;&nbsp;</a></span>save_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt; void &gt; epi::save_result </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save secir simulation result to h5 file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>Vector of timesteps used during simulation </td></tr>
    <tr><td class="paramname">secir</td><td>Results of secir simulation </td></tr>
    <tr><td class="paramname">filename</td><td>name of file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa8a378052ad704e7ac76df0f0420d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8a378052ad704e7ac76df0f0420d9b">&#9670;&nbsp;</a></span>secir_get_derivatives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::secir_get_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1SecirParams.html">SecirParams</a> const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>pop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>dydt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67eb3f9715193049cfe02fa1ae923024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67eb3f9715193049cfe02fa1ae923024">&#9670;&nbsp;</a></span>seconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1TimeSpan.html">TimeSpan</a> epi::seconds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a <a class="el" href="classepi_1_1TimeSpan.html" title="a duration of time.">TimeSpan</a> of a specified number of seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>number of seconds in the time span. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7695ed10dce7f77ba45a6a208aa801c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7695ed10dce7f77ba45a6a208aa801c">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::serialize </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save data that describes an object in a format determined by the given context. </p>
<p>There must be provided for the type T either a free function <code>serialize_internal(io, t)</code> that can be found using argument dependent lookup (ADL) or a member function <code>t.serialize(io)</code>. The <code>serialize_internal</code> function or <code>serialize</code> member function provide the data that describes the object to the io context. The context stores the data in some unspecified format so that the objects can be reconstructed from it. The context also keeps track of any IO errors. <code>serialize_internal</code> overloads are already provided for many common types, e.g. STL containers or Eigen Matrices. <code>serialize</code> and <code>deserialize</code> are the main entry point into this IO framework, but there may be more convenient functions provided for specific IO contexts. These functions are not expected to use ADL, so should be called namespace qualified. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">T</td><td>any serializable type, i.e., that has a <code>serialize</code> member function or <code>serialize_internal</code> overload </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>io context that stores data from the object t in some unspecified format. </td></tr>
    <tr><td class="paramname">t</td><td>the object to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab963398e0444e5a1fc0f8d473fbf046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab963398e0444e5a1fc0f8d473fbf046d">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class Container , std::enable_if_t&lt;(is_container&lt; Container &gt;::value &amp;&amp;!is_expression_valid&lt; serialize_t, IOContext, Container &gt;::value), void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an STL compatible container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">Container</td><td>the container type to be serialized. A container is anything with begin and end iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">container</td><td>a container to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f38e8c2daba6e250ec1399f37deb68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f38e8c2daba6e250ec1399f37deb68e">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::EigenBase&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an Eigen matrix expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">M</td><td>the type of Eigen matrix expression to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix expression to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abab9b29e11eb8c5c74c20ac9e665f35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab9b29e11eb8c5c74c20ac9e665f35c">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class T , std::enable_if_t&lt; is_expression_valid&lt; serialize_t, IOContext, T &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an object that has a serialize(io) member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">T</td><td>the Type of the object to be serialized. Must have a serialize member function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context </td></tr>
    <tr><td class="paramname">t</td><td>the object to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76604f8ba20f3c1f7f5f057a57b4e526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76604f8ba20f3c1f7f5f057a57b4e526">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class Tup , class  = std::enable_if_t&lt;is_expression_valid&lt;details::tuple_size_value_t, Tup&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tup &amp;&#160;</td>
          <td class="paramname"><em>tup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize a tuple-like object, e.g. </p>
<p>std::tuple or std::pair. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">Tup</td><td>the tuple-like type to be serialized, i.e. anything that supports tuple_size and tuple_element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context. </td></tr>
    <tr><td class="paramname">tup</td><td>a tuple-like object to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefa07e252e4e11d512ffc40b255a1cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa07e252e4e11d512ffc40b255a1cfe">&#9670;&nbsp;</a></span>serialize_internal() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IOContext , class E , std::enable_if_t&lt; std::is_enum&lt; E &gt;::value, void * &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::serialize_internal </td>
          <td>(</td>
          <td class="paramtype">IOContext &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialize an enum value as its underlying type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IOContext</td><td>a type that models the IOContext concept. </td></tr>
    <tr><td class="paramname">E</td><td>an enum type to be serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>an IO context </td></tr>
    <tr><td class="paramname">e</td><td>an enum value to be serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d53cc671d69af5461a92c2b05dd0526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d53cc671d69af5461a92c2b05dd0526">&#9670;&nbsp;</a></span>serialize_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;Json::Value&gt; epi::serialize_json </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an object into json. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of value to be serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the object to be serialized. </td></tr>
    <tr><td class="paramname">flags</td><td>flags that determine the behavior of serialized; see <a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724" title="flags to determine the behavior of the serialization process.">epi::IOFlags</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>json value if serialization is succesful, error code otherwise. </dd></dl>

</div>
</div>
<a id="a9c664f7bae0d089839cd34c9299f5c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c664f7bae0d089839cd34c9299f5c1e">&#9670;&nbsp;</a></span>set_home_office()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::set_home_office </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname"><em>t_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LockdownRules implements non phamarceutical interventions via dampings. </p>
<p>For interventions, people are randomly divided into groups, e.g. one group works at home and the other group still goes to work. The probability with which a person belongs to a certain group is time dependet. This change in probabilty is implemented by using dampings. Persons who are in home office are staying at home instead of going to work. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_begin</td><td>begin of the intervention </td></tr>
    <tr><td class="paramname">p</td><td>percentage of people that work in home office </td></tr>
    <tr><td class="paramname">params</td><td>migration parameters that include damping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae07a4860425456127bbc2061666ab52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07a4860425456127bbc2061666ab52d">&#9670;&nbsp;</a></span>set_log_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::set_log_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#a4d44f54b29b6a8e746bef68135a3ac60">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the verbosity of the logger. </p>

</div>
</div>
<a id="a002f18b08370fd888f6d2064a4fd24a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002f18b08370fd888f6d2064a4fd24a6">&#9670;&nbsp;</a></span>set_params_distributions_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::set_params_distributions_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dev_rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bd09e2f4ab61892c97cc8344764ceae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd09e2f4ab61892c97cc8344764ceae">&#9670;&nbsp;</a></span>set_school_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void epi::set_school_closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classepi_1_1TimePoint.html">TimePoint</a>&#160;</td>
          <td class="paramname"><em>t_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceepi.html#a6b1a9c4fa2e196c5559ef49ec1a5853c">AbmMigrationParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If schools are closed, students stay at home instead of going to school. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_begin</td><td>begin of the intervention </td></tr>
    <tr><td class="paramname">p</td><td>percentage of people that are homeschooled </td></tr>
    <tr><td class="paramname">params</td><td>migration parameters that include damping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a420b40f813bf76d271632438acb1f6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420b40f813bf76d271632438acb1f6a2">&#9670;&nbsp;</a></span>simulate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto epi::simulate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classepi_1_1SecirModel.html">SecirModel</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classepi_1_1IntegratorCore.html">IntegratorCore</a> &gt;&#160;</td>
          <td class="paramname"><em>integrator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specialization of simulate for secir models using <a class="el" href="classepi_1_1SecirSimulation.html" title="specialization of compartment model simulation for secir models.">SecirSimulation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>start time. </td></tr>
    <tr><td class="paramname">tmax</td><td>end time. </td></tr>
    <tr><td class="paramname">dt</td><td>time step. </td></tr>
    <tr><td class="paramname">model</td><td>secir model to simulate. </td></tr>
    <tr><td class="paramname">integrator</td><td>optional integrator, uses rk45 if nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d3f2fcd2c303060c062fce863683646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3f2fcd2c303060c062fce863683646">&#9670;&nbsp;</a></span>simulate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model , class Sim  = Simulation&lt;Model&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt;<a class="el" href="ScalarType_8h.html#acd4f1d492d83a74716a42615e127d641">ScalarType</a>&gt; epi::simulate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model const &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classepi_1_1IntegratorCore.html">IntegratorCore</a> &gt;&#160;</td>
          <td class="paramname"><em>integrator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simulate simulates a compartmental model </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t0</td><td>start time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmax</td><td>end time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>initial step size of integration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>An instance of a compartmental model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classepi_1_1TimeSeries.html" title="stores vectors of values at time points (or some other abstract variable) the value at each time poin...">TimeSeries</a> to represent the final simulation result </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Model</td><td>a compartment model type </td></tr>
    <tr><td class="paramname">Sim</td><td>a simulation type that can simulate the model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac668a516b3b81430fd9db1655be8ca3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac668a516b3b81430fd9db1655be8ca3c">&#9670;&nbsp;</a></span>simulate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt;double&gt; epi::simulate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classepi_1_1SecirParams.html">SecirParams</a> const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04a009607559caffa453a30d1f34b92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a009607559caffa453a30d1f34b92b">&#9670;&nbsp;</a></span>slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , std::enable_if_t&lt; is_dynamic_matrix&lt; M &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::slice </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structepi_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structepi_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take a regular slice of a matrix. </p>
<p>The slices shares the same memory as the original matrix, no copying is performed, changes to the slice are also made to the original matrix. Assign to a different matrix of compatible size if you need a copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix to take a slice of </td></tr>
    <tr><td class="paramname">rows</td><td>sequence of row indices </td></tr>
    <tr><td class="paramname">cols</td><td>sequence of column indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matrix expression with selected entries from the input matrix </dd></dl>

</div>
</div>
<a id="a958f73d77f1bccbe6ba775f02b2f94ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958f73d77f1bccbe6ba775f02b2f94ff">&#9670;&nbsp;</a></span>slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , std::enable_if_t&lt; is_dynamic_vector&lt; V &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::slice </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structepi_1_1Seq.html">Seq</a>&lt; Eigen::Index &gt;&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take a regular slice of a row or column vector. </p>
<p>The slices shares the same memory as the original vector, no copying is performed, changes to the slice are also made to the original vector. Assign to a different vector of compatible size if you need a copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Row or column vector to take a slice of </td></tr>
    <tr><td class="paramname">elems</td><td>sequence of row or column indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector expression with selected entries from the input vector </dd></dl>

</div>
</div>
<a id="a27d384302b65a9ac67422556a8b71824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d384302b65a9ac67422556a8b71824">&#9670;&nbsp;</a></span>smoother_cosine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LeftExpr , class RightExpr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::smoother_cosine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xright</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; LeftExpr &gt; &amp;&#160;</td>
          <td class="paramname"><em>yleft_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; RightExpr &gt; &amp;&#160;</td>
          <td class="paramname"><em>yright_expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smoother_cosine as a matrix valued function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>evaluation point </td></tr>
    <tr><td class="paramname">xleft</td><td>left boundary x </td></tr>
    <tr><td class="paramname">xright</td><td>right boundary x </td></tr>
    <tr><td class="paramname">yleft</td><td>matrix expression, function value at left boundary </td></tr>
    <tr><td class="paramname">yright</td><td>matrix expression, function value at right boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matrix expression with yij = smoother_cosine(x, xleft, xright, yleftij, yrightij) </dd></dl>

</div>
</div>
<a id="abcd4a5a005de9c26fe1a3e350db3b939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd4a5a005de9c26fe1a3e350db3b939">&#9670;&nbsp;</a></span>smoother_cosine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double epi::smoother_cosine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xright</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smoothed evaluation of a discrete jump of function values <br  />
 yleft and yright on xleft and xright, respectively, by using a cosine function. </p>
<p>If the input value is outside the given interval, yleft or yright are returned, respectively. { yleft, for x &lt;= xleft f(x) = { yright, for x &gt;= xright { 0.5*(yleft - yright)*cos(pi/(xright-xleft)*(x-xleft))+0.5*(yleft + yright) for x\in[xleft,xright] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>current evaluation point </td></tr>
    <tr><td class="paramname">xleft</td><td>left boundary of independent variable </td></tr>
    <tr><td class="paramname">xright</td><td>right boundary of independent variable </td></tr>
    <tr><td class="paramname">yleft</td><td>function value at left boundary </td></tr>
    <tr><td class="paramname">yright</td><td>function value at right boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double cosine-smoothed evaluation of discrete step function </dd></dl>

</div>
</div>
<a id="aa3a727e393588b9f803e41b5e994baa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a727e393588b9f803e41b5e994baa2">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; epi::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits string into a Vector of strings according to delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string which is splitted </td></tr>
    <tr><td class="paramname">delimiter</td><td>sign at which to split string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1ebb94e07f7faaadcb49c06e7cb5f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ebb94e07f7faaadcb49c06e7cb5f68">&#9670;&nbsp;</a></span>status_code_category()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classepi_1_1detail_1_1StatusCodeCategory.html">detail::StatusCodeCategory</a>&amp; epi::status_code_category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>singleton StatusCodeCategory instance. </p>

</div>
</div>
<a id="afb9e70f5748c7a821d499813f11272b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9e70f5748c7a821d499813f11272b6">&#9670;&nbsp;</a></span>store_group_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">herr_t epi::store_group_name </td>
          <td>(</td>
          <td class="paramtype">hid_t&#160;</td>
          <td class="paramname"><em>loc_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const H5L_info_t *&#160;</td>
          <td class="paramname"><em>linfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f628fcc67b59148c234bc6dd75d0e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f628fcc67b59148c234bc6dd75d0e94">&#9670;&nbsp;</a></span>success() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto epi::success </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object that is implicitly convertible to a succesful IOResult&lt;void&gt;. </p>
<p>Use <code>return <a class="el" href="namespaceepi.html#a4f628fcc67b59148c234bc6dd75d0e94" title="Create an object that is implicitly convertible to a succesful IOResult&lt;void&gt;.">success()</a></code> to conveniently return a successful result from a function. </p>

</div>
</div>
<a id="a4f3b5f5f62023c9f197bf5c030b009f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3b5f5f62023c9f197bf5c030b009f3">&#9670;&nbsp;</a></span>success() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto epi::success </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object that is implicitly convertible to a succesful IOResult. </p>
<p>Use <code>return success(t)</code> to conveniently return a successful result from a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>a value that is convertible to the value type of the IOResult </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0088307255fc1f637105e021df538a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0088307255fc1f637105e021df538a5c">&#9670;&nbsp;</a></span>sum_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt; &gt; &gt; epi::sum_nodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classepi_1_1TimeSeries.html">TimeSeries</a>&lt; double &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ensemble_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a483d09848b2a8a36d8c9cc53c5320097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483d09848b2a8a36d8c9cc53c5320097">&#9670;&nbsp;</a></span>thread_local_rng()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classepi_1_1RandomNumberGenerator.html">RandomNumberGenerator</a>&amp; epi::thread_local_rng </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a random number generator that is static and local to this thread. </p>
<dl class="section return"><dt>Returns</dt><dd>a random number generator that is static and local to this thread. </dd></dl>

</div>
</div>
<a id="a857d9dfd1881502919d7dca04d65b73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857d9dfd1881502919d7dca04d65b73f">&#9670;&nbsp;</a></span>unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void epi::unused </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does nothing, can be used to mark variables as not used. </p>
<p>e.g. for avoiding compiler warnings/error about unused variables. </p>

</div>
</div>
<a id="ab2cc48c909d42717f5ea6b15767b7ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cc48c909d42717f5ea6b15767b7ca1">&#9670;&nbsp;</a></span>write_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Model &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;void&gt; epi::write_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Graph.html">Graph</a>&lt; Model, <a class="el" href="classepi_1_1MigrationParameters.html">MigrationParameters</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioflags</em> = <code><a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates json files for each node in a simulation graph. </p>
<p>Creates two files per node: one contains the models and its parameters, one contains the outgoing edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="classepi_1_1Graph.html" title="generic graph structure">Graph</a> which should be written </td></tr>
    <tr><td class="paramname">directory</td><td>directory where files should be stored </td></tr>
    <tr><td class="paramname">ioflags</td><td>flags that set the behavior of serialization; see <a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724" title="flags to determine the behavior of the serialization process.">epi::IOFlags</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae41b4e70ad6fc1980e0cc4e4c3dd8540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41b4e70ad6fc1980e0cc4e4c3dd8540">&#9670;&nbsp;</a></span>write_json() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;void&gt; epi::write_json </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>js_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the json value into a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path of the file. </td></tr>
    <tr><td class="paramname">js_value</td><td>json value to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing if succesful, error code otherwise. </dd></dl>

</div>
</div>
<a id="ac3aef7086e16a8429d491b36e706c2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aef7086e16a8429d491b36e706c2cd">&#9670;&nbsp;</a></span>write_json() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;void&gt; epi::write_json </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724a4f2803def6b19ccb754ef1a077a79b01">IOF_None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an object into json and write it into a file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of value to be serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path of the file. </td></tr>
    <tr><td class="paramname">t</td><td>the object to be serialized. </td></tr>
    <tr><td class="paramname">flags</td><td>flags that determine the behavior of the serialization; see <a class="el" href="namespaceepi.html#a1bf67eb2c517123112248a0025645724" title="flags to determine the behavior of the serialization process.">epi::IOFlags</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing if succesful, error code otherwise. </dd></dl>

</div>
</div>
<a id="a291d75c53062273651edb8b64455d144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291d75c53062273651edb8b64455d144">&#9670;&nbsp;</a></span>write_single_run_result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Simulation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceepi.html#a89f5e00dd122b11fad06af0f2e72ee1a">IOResult</a>&lt;void&gt; epi::write_single_run_result </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classepi_1_1Graph.html">epi::Graph</a>&lt; <a class="el" href="classepi_1_1SimulationNode.html">epi::SimulationNode</a>&lt; <a class="el" href="classepi_1_1Simulation.html">Simulation</a> &gt;, <a class="el" href="classepi_1_1MigrationEdge.html">epi::MigrationEdge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates xml file with a single run parameter study with std 0 (used to save parameters of individual runs) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file </td></tr>
    <tr><td class="paramname">params</td><td>Secir parameters used during run </td></tr>
    <tr><td class="paramname">t0</td><td>starting point of simulation </td></tr>
    <tr><td class="paramname">tmax</td><td>end point of simulation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9deae6f690facc4fe4d3d3641c1f0458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9deae6f690facc4fe4d3d3641c1f0458">&#9670;&nbsp;</a></span>conjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool epi::conjunction_v = <a class="el" href="structepi_1_1conjunction.html">conjunction</a>&lt;Bs...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa18a8a514f71a62488fa878d3a1e281d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18a8a514f71a62488fa878d3a1e281d">&#9670;&nbsp;</a></span>INVALID_LOCATION_INDEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t epi::INVALID_LOCATION_INDEX = std::numeric_limits&lt;uint32_t&gt;::<a class="el" href="namespaceepi.html#ad671e5cd3a4ab1b63f066b3b7d4e7e2f">max</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceepi_html_ad6c8b9491165ac4a30ac7f9208975056"><div class="ttname"><a href="namespaceepi.html#ad6c8b9491165ac4a30ac7f9208975056">epi::Tag</a></div><div class="ttdeci">boost::outcome_v2::in_place_type_t&lt; T &gt; Tag</div><div class="ttdoc">Type that is used for overload resolution.</div><div class="ttdef"><b>Definition:</b> io.h:503</div></div>
<div class="ttc" id="anamespaceepi_html_a9e11480551689fac0a957df08e757bf9"><div class="ttname"><a href="namespaceepi.html#a9e11480551689fac0a957df08e757bf9">epi::deserialize</a></div><div class="ttdeci">IOResult&lt; T &gt; deserialize(IOContext &amp;io, Tag&lt; T &gt; tag)</div><div class="ttdoc">Restores an object from the data stored in an IO context.</div><div class="ttdef"><b>Definition:</b> io.h:908</div></div>
<div class="ttc" id="anamespaceepi_html_a4f628fcc67b59148c234bc6dd75d0e94"><div class="ttname"><a href="namespaceepi.html#a4f628fcc67b59148c234bc6dd75d0e94">epi::success</a></div><div class="ttdeci">auto success()</div><div class="ttdoc">Create an object that is implicitly convertible to a succesful IOResult&lt;void&gt;.</div><div class="ttdef"><b>Definition:</b> io.h:455</div></div>
<div class="ttc" id="anamespaceepi_html_ab7695ed10dce7f77ba45a6a208aa801c"><div class="ttname"><a href="namespaceepi.html#ab7695ed10dce7f77ba45a6a208aa801c">epi::serialize</a></div><div class="ttdeci">void serialize(IOContext &amp;io, const T &amp;t)</div><div class="ttdoc">Save data that describes an object in a format determined by the given context.</div><div class="ttdef"><b>Definition:</b> io.h:884</div></div>
<div class="ttc" id="anamespaceepi_html_a15a2504363f09ad496faf88547925bef"><div class="ttname"><a href="namespaceepi.html#a15a2504363f09ad496faf88547925bef">epi::apply</a></div><div class="ttdeci">details::ApplyResultT&lt; F, T... &gt; apply(IOContext &amp;io, F f, const IOResult&lt; T &gt; &amp;... rs)</div><div class="ttdoc">Evaluate a function with zero or more unpacked IOResults as arguments.</div><div class="ttdef"><b>Definition:</b> io.h:575</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
